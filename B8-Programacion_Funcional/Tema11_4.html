<!DOCTYPE html><html><head>
      <title>Introducción a la Programación Funcional</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
@font-face {
  font-family: 'Catamaran';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/catamaran/v19/o-0bIpQoyXQa2RxT7-5B6Ryxs2E_6n1iPHjd5a7dvg.ttf) format('truetype');
}
.markdown-preview.markdown-preview .contenedor {
  display: flex;
  justify-content: center;
  margin: 30px auto 30px auto;
}
.markdown-preview.markdown-preview .fondo {
  background: url(https://programacioniesbalmis.github.io/Imagenes/BannersMoodle/banner.png);
  background-size: cover;
  width: 75%;
  height: 160px;
  border-radius: 10px;
  position: relative;
}
.markdown-preview.markdown-preview .cita {
  font-family: Arial;
  font-style: italic;
  font-weight: 600;
  text-align: justify;
  line-height: 1.5rem;
  opacity: 0.6;
  color: white;
  padding: 5rem;
  position: relative;
  top: 50%;
  left: 50%;
  font-size: 1.3rem;
  transform: translate(-50%, -50%);
}
.markdown-preview.markdown-preview .abre_comilla {
  font-family: "Catamaran";
  font-weight: 600;
  color: white;
  padding-left: 30px;
  position: absolute;
  font-size: 6rem;
  transform: translate(0%, -15%);
}
.markdown-preview.markdown-preview .cierra_comilla {
  font-family: "Catamaran";
  font-weight: 600;
  color: white;
  padding-right: 30px;
  right: 0%;
  position: absolute;
  font-size: 6rem;
  transform: translate(0%, 55%);
}
.markdown-preview.markdown-preview .autor {
  font-family: Arial;
  color: white;
  margin: 0px;
  padding-left: 30px;
  position: absolute;
  top: 83%;
  font-size: 1rem;
}

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="tema-114">Tema 11.4 </h1>
<p>Descargar estos apuntes en <a href="./Tema11_4.pdf">pdf</a> o <a href="./Tema11_4.html">html</a></p>
<h2 id="índice">Índice </h2>

<div class="md-toc">
<details style="padding:0;;padding-left:0px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#introducción-a-la-programación-funcional" class="md-toc-link"><p>Introducción a la Programación Funcional</p>
</a>
          </summary>
        <div>
          <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#cálculo-lambda" class="md-toc-link"><p>Cálculo Lambda</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#definición-de-expresión-lambda" class="md-toc-link">
            <p>Definición de Expresión Lambda</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#expresiones-lambda-en-c" class="md-toc-link">
            <p>Expresiones Lambda en C#</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#clausuras-en-csharp" class="md-toc-link"><p>Clausuras en CSharp</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#variables-externas-capturadas" class="md-toc-link">
            <p>Variables Externas Capturadas</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#patrón-map-filter-fold" class="md-toc-link"><p>Patrón Map-Filter-Fold</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#map-o-select" class="md-toc-link">
            <p>Map (o Select)</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#filter-o-where" class="md-toc-link">
            <p>Filter (o Where)</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#fold-o-aggregate" class="md-toc-link">
            <p>Fold (o Aggregate)</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#combinando-las-tres-operaciones" class="md-toc-link">
            <p>Combinando las tres operaciones</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#otras-operaciones-funcionales-declarativas-en-c" class="md-toc-link"><p>Otras operaciones funcionales declarativas en C#</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#orderbyorderbydescending" class="md-toc-link">
            <p>OrderBy/OrderByDescending</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#distinct" class="md-toc-link">
            <p>Distinct</p>

          </a></div><details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#groupby" class="md-toc-link"><p>GroupBy</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#resultado-del-groupby-en-un-nuevo-tipo-de-datos" class="md-toc-link">
            <p>Resultado del GroupBy en un nuevo tipo de datos</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#resultado-del-grupby-en-un-diccionario" class="md-toc-link">
            <p>Resultado del GrupBy en un diccionario</p>

          </a></div>
        </div>
      </details>
    <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#zip" class="md-toc-link">
            <p>Zip</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#flatmap-o-aplanado" class="md-toc-link">
            <p>FlatMap o Aplanado</p>

          </a></div>
        </div>
      </details>
    
        </div>
      </details>
    
</div>
<div style="page-break-after:always;"></div>
<h2 id="introducción-a-la-programación-funcional">Introducción a la Programación Funcional </h2>
<p>La <strong>programación funcional</strong> es un <strong>paradigma de programación declarativa</strong> basado en el uso de <strong>funciones matemáticas</strong>, en contraste con la programación <strong>imperativa</strong>, que enfatiza los cambios de estado mediante la mutación de variables.</p>
<p>Existen lenguaje de programación funcionales puros como por ejemplo <strong><a href="https://es.wikipedia.org/wiki/Haskell">Haskell</a></strong> y <strong><a href="https://es.wikipedia.org/wiki/Clojure">Clojure</a></strong>. Sin embargo, el paradigma funcional ha ido cogiendo cada vez más peso en la programación moderna. Tanto es así, que lenguajes imperativos y orientados a objetos tradicionales como <strong>C++</strong>, <strong>Java</strong>, <strong>C#</strong> o <strong>PHP</strong> han incluido características de la programación funcional en su sintáxis o potenciando las que ya tenían lenguajes como <strong>JavaScript</strong>, <strong>Python</strong>. Además, los lenguajes multi-paradigma de nueva creación como <strong>Scala</strong>, <strong>Go</strong>, <strong>F#</strong> o <strong>Kotlin</strong> (este último en menor medida) se han diseñado para que tenga más peso la programación funcional que la orientada a objetos e imperativa.</p>
<p>Simplificando y a grandes rasgos podemos decir que <strong>se basa en los siguientes pilares</strong> matemáticos:</p>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Lambda_calculus">Cálculo Lambda</a>.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">Clausuras</a>.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Category_theory">Teoría de categorías</a> y más en concreto el concepto de <a href="https://en.wikipedia.org/wiki/Functor">functor</a> y su aplicación a las ciencias de la computación a través de:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Monad_(category_theory)">Mónadas</a>.</li>
<li><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">Covarianza y Contravarianza.</a></li>
</ul>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Recursion">Recursión o Recursividad</a> (Formaría parte del Cálculo Lambda).</p>
</li>
</ul>
<p>Cómo se puede observar, su bases son bastante ámplias y llevaría bastante ahondar todos estos conceptos. Por esta razón, este tema pretende ser méramente introductorío y por tanto en él solo vamos a abordar algunos conceptos a través del lenguaje C#. Estos conceptos serán extrapolables a otros lenguajes ya que como hemos comentados todos utilizan, en mayor o medida, dicho paradigma.</p>
<h3 id="cálculo-lambda">Cálculo Lambda </h3>
<p>Es uno de los pilares de la programación funcional. Esté fue formulado por el matemático-lógico norteamericano <strong>Alonzo Church</strong> y consiste en '<em>...un sistema formal diseñado para investigar la definición de función, la noción de aplicación de funciones y la recursión...</em>'.</p>
<p>Se basa en una definición de función alternativa a la tradicional que dentro del contexto de las ciencias de computación denominaremos: <strong>'<em>Expresión Lambda</em>'</strong>.</p>
<h4 id="definición-de-expresión-lambda">Definición de Expresión Lambda </h4>
<p>Para entender lo que es, vamos ver el concepto de función dependiendo de ámbito de conocimiento...</p>
<ol>
<li>
<p>En <strong>matemática tradicional</strong> las funciones se representan con un nombre <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> o <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></p>
<table>
<thead>
<tr>
<th>Definición</th>
<th>Explicación</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(x)=x+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></td>
<td>Un parámetro.</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">pow(x, y)=x^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></td>
<td>Dos parámetros.</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>En la <strong>teoría matemática del cálculo lambda</strong> (<em>λ-calculus</em>) esta misma función <strong>se expresaría sin nombre</strong>, solo los parámetros que entran y la expresión que la representa.</p>
<table>
<thead>
<tr>
<th>Definición</th>
<th>Explicación</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">λx.x+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></td>
<td>Un parámetro (definición) y equivale a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(x)=x+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>.</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mn>10</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">(λx.x+2)10=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></td>
<td>Un parámetro (aplicación de una valor) y equivale a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mn>10</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">f(10)=10+2=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">10</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>.</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><msup><mi>x</mi><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">λ(x,y).x^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></td>
<td>Dos parámetros.</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>✋ En <strong>ciencias de computación</strong> se expresará a través de una <strong>función anónima o expresión lambda</strong>.</p>
<table>
<thead>
<tr>
<th>Definición</th>
<th>Explicación</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x → x+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></td>
<td>Un parámetro (definición) y equivale a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(x)=x+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>.</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>→</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">(x → x+2)(10) = 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">10</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></td>
<td>Un parámetro (aplicación de un valor) y equivale a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mn>10</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">f(10)=10+2=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">10</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>.</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>x</mi><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">(x,y) → x^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></td>
<td>Dos parámetros.</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>Esta última, forma de definir funciones de forma anónima y como expresiones, es la que usaremos el la gran mayoría de lenguajes de programación y aunque vamos a ver el caso concreto de C#, la forma de hacelos será muy similar en otros lenguajes. Por<br>
ejemplo, si ya las hemos usado en JavaScript, su sintaxis nos será muy familiar.</p>
<h4 id="expresiones-lambda-en-c">Expresiones Lambda en C# </h4>
<p>Una <strong>λ-expresión</strong> en C# es un <strong>método anónimo</strong> (sin nombre) que se ha de declarar/definir y asignar inmediatamente, sobre una instancia de un <strong>delegado</strong>.</p>
<p>Las λ-expresión puede ser usadas en alguno estos escenarios en C#:</p>
<ol>
<li>
<p>Definir cuerpos de expresión dentro de una clase (<strong>Esto ya lo hemos usado</strong>).</p>
<blockquote>
<p>📌 <strong>Nota:</strong> Por ejemplo, un cuerpo de expresión es una expresión lambda.</p>
</blockquote>
</li>
<li>
<p>Pasar como argumento a otra función.</p>
</li>
<li>
<p>Como tipo de retorno de una función, esto es, '<em>Una función que retorna otra función</em>.</p>
</li>
<li>
<p>Asignación a instancias de delegados parametrizados.</p>
</li>
</ol>
<p>La representación general de una expresión lambda sigue el  siguiente formato general...</p>
<p><strong><code>(parámetros) =&gt; sentencia o {bloque de sentencias con return si función}</code></strong></p>
<p>Vamos a describir que es cada cosa:</p>
<ol>
<li>
<p><strong><code>(parámetros)</code></strong>: Lista de parámetros separada por comas.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Math<span class="token punctuation">.</span><span class="token function">Pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Se debe dejar los paréntesis vacíos <strong><code>()</code></strong> si no hay parámetros.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Hola"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Si solo hay <strong>un parámetro</strong>, los paréntesis se pueden obviar.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Suponiendo que s es de tipo string la expresión lambda siguiente</span>
<span class="token comment">// se evaluará a tipo delegado Func&lt;string, int&gt; esto es, una función anónima</span>
<span class="token comment">// que recibe un string y retorna un int.</span>
s <span class="token operator">=&gt;</span> s<span class="token punctuation">.</span>Lenght<span class="token punctuation">;</span>
</code></pre></li>
<li>
<p><strong><code>=&gt;</code></strong>: Este es el <strong>operador</strong> que se encarga de mapear los parámetros a la expresión o al conjunto de sentencias del bloque.</p>
</li>
<li>
<p>La parte derecha, tras el operador <strong><code>=&gt;</code></strong>, puede ser una única sentencia en forma de expresión que se evalúe a lo que retorna la función como en lo ejemplo anteriores o de forma menos habitual, un bloque de instrucciones. En este último caso la sintáxis será equivalente a la de las funciones tradicionales y tratando de sangrar el código y escribirla en varias líneas para mayor claridad.</p>
<pre data-role="codeBlock" data-info="csharp {highlight=4}" class="language-csharp csharp" data-line="4"><code><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> 
<span class="token punctuation">{</span> 
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Calculando </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">x</span><span class="token punctuation">}</span></span><span class="token string"> elevado a </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">y</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword keyword-return">return</span> Math<span class="token punctuation">.</span><span class="token function">Pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Fíjate que ahora sí debemos usar return.</span>
<span class="token punctuation">}</span>
</code><div class="line-highlight-wrapper">


<div aria-hidden="true" class="line-highlight" data-range="4" data-start="4">
</div></div></pre></li>
</ol>
<p>Las expresiones lambda anteriores anteriores de forma análoga a lo que sucedería con la expresión <strong><code>int x = 3 + 4</code></strong>, deberemos asignarla a algo. Puesto que los tipos que referencian a funciones son los objetos delegado, deberemos asignarlo a algún identificador de objeto delegado parametrizado o no. Es más, <strong>será completamente necesario para deducir los tipos de los parámetros de entrada y de retorno</strong>.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// x es double y retorna double</span>
<span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">&gt;</span></span> cubo <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>

<span class="token comment">// x , y son enteros y retorna entero</span>
<span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> suma <span class="token operator">=</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> o1 <span class="token operator">+</span> o2<span class="token punctuation">;</span> 

<span class="token comment">// ERROR no sé deducir los tipos de forma implícita.</span>
<span class="token comment">// Esto solo sería válido en un lenguaje débilmente tipado como JavaScript.</span>
<span class="token class-name"><span class="token keyword keyword-var">var</span></span> suma <span class="token operator">=</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> o1 <span class="token operator">+</span> o2<span class="token punctuation">;</span>
</code></pre><h3 id="clausuras-en-csharp">Clausuras en CSharp </h3>
<p>Para entender el concepto de <strong><a href="https://es.wikipedia.org/wiki/Clausura_(inform%C3%A1tica)">clausura</a></strong>, vamos a ver los siguiente definición del lenguaje C#.</p>
<h4 id="variables-externas-capturadas">Variables Externas Capturadas </h4>
<p>En el cuerpo de expresión de una expresión lambda, podemos incluir referencias a variables locales y a los parámetros de un método. A estas referencias se les conoce como <strong>variables externas capturadas</strong>.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Variable local factor, su alcance o scope es la el método A</span>
    <span class="token comment">// fuera del mismo la variable dejará de existir.</span>
    <span class="token class-name"><span class="token keyword keyword-int">int</span></span> factor <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 

    <span class="token comment">// factor es una variable externa capturada en la expresión lambda pues </span>
    <span class="token comment">// está siendo usada en un ámbito más cercano.</span>
    <span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> producto <span class="token operator">=</span> n <span class="token operator">=&gt;</span> n <span class="token operator">*</span> factor<span class="token punctuation">;</span>

    <span class="token comment">// Como hago una invocación del delegado dentro del scope de A</span>
    <span class="token comment">// factor sigue existiendo y valiendo 3 por lo que al ejecutarse</span>
    <span class="token comment">// el cuerpo de expresión de la función lambda a la que referencia</span>
    <span class="token comment">// se mostrará 5 * 3 = 15</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">producto</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>A las <strong>expresiones lambda</strong> que están integradas por variables externas capturadas se les llama <strong>clausuras</strong>.</p>
<p>Este tipo de variables, se evalúan en el momento en que se llama a la expresión Lambda de tal manera que si reescribiéramos el código anterior así ...</p>
<pre data-role="codeBlock" data-info="csharp {highlight=5}" class="language-csharp csharp" data-line="5"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-int">int</span></span> factor <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 
    <span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> producto <span class="token operator">=</span> n <span class="token operator">=&gt;</span> n <span class="token operator">*</span> factor<span class="token punctuation">;</span>
    factor <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token comment">// Ahora mostrará 5 * 10 = 50 porque evalúa el valor de factor en</span>
    <span class="token comment">// el momento de la llama a la función anónima.</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">producto</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mostrará 50</span>
<span class="token punctuation">}</span>
</code><div class="line-highlight-wrapper">



<div aria-hidden="true" class="line-highlight" data-range="5" data-start="5">
</div></div></pre><p>La referencia y el valor a una variable capturada, <strong>está disponible mientras el ámbito de la expresión lambda</strong> esté al alcance de su ejecución. Esto es, a pesar de encontrarnos fuera el ámbito de definición de la variable externa capturada, se guarda una referencia y siempre estará accesible para la expresión lambda.</p>
<p>Pero, en nuestro ejemplo <strong><code>producto</code></strong> que es la referencia a nuestra expresión lambda y <strong><code>factor</code></strong> que es la variable externa capturada, tienen el mismo ámbito de ejecución que es el método <strong><code>A</code></strong>, esto es, ambas referencias existen en el heap mientras estoy ejecutando <strong><code>A</code></strong> y al finalizar el método desaparecen. Entonces... <strong>¿Cómo puede extenderse el ámbito de ejecución de <strong><code>producto</code></strong> más allá del ámbito de existencia de <strong><code>factor</code></strong>?</strong></p>
<p>La respuesta es, mediante <strong>funciones de orden superior</strong> o <strong>HOF</strong> (<a href="https://en.wikipedia.org/wiki/Higher-order_function">High-Order Functions</a>). Las HOF en el λ-cálculo podemos resumir que <strong>son funciones que reciben como parámetro o retornan otra función</strong>.</p>
<p>¿Cómo pasamos por parámetro o devolvemos una función en C#?. La respuesta sería a través de un tipo delegado. Entonces, cuando vimos los delegados ... ¿Aquellos métodos que recibían un delegado eran HOF?. La respuesta es <strong>sí</strong>.</p>
<p>¿Cómo redactaremos el código anterior para que el método <strong><code>A</code></strong> sea una HOF y la función lambda (clausura) tenga un alcance de ejecución más allá de su ámbito de definición?. Una posible propuesta sería la siguiente ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Ahora el método A es HOF porque retorna una función</span>
<span class="token keyword keyword-static">static</span> <span class="token return-type class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-int">int</span></span> factor <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> n <span class="token operator">=&gt;</span> n <span class="token operator">*</span> factor<span class="token punctuation">;</span>    
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-var">var</span></span> producto <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// A() ha desvuelto el control a Main y se supone que la variable local factor</span>
    <span class="token comment">// ya ha desaparecido. Sin embargo, la clausura que la capturaba aún está </span>
    <span class="token comment">// referenciada por el delegado producto y por tanto aún la podemos ejecutar.</span>
    <span class="token comment">// Al no desaparecer el alcance de ejecución la variable capturada factor aún</span>
    <span class="token comment">// no ha desaparecido de la memoria y tendrá el último valor que se le asignó</span>
    <span class="token comment">// que es 3.</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">producto</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mostrará 15</span>
<span class="token punctuation">}</span>
</code></pre><div style="page-break-after:always;"></div>
<blockquote>
<p>📣 <strong>Resumen:</strong></p>
<p>Es momento de realizar una breve recapitulación de conceptos...</p>
<p>En programación funcional (λ-cálculo) se denominan funciones de orden superior (HOF), aquellas que:</p>
<ol>
<li>Reciben como parámetro otra función <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>→</mo><msub><mi>r</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>r</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">(r_1 → r_2) → r_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>Devuelven como parámetro otra función <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>→</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mn>2</mn></msub><mo>→</mo><msub><mi>r</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r_1 → (r_2 → r_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>O ambas cosas <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>→</mo><msub><mi>r</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mn>3</mn></msub><mo>→</mo><msub><mi>r</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_1 → r_2) → (r_3 → r_4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li>
</ol>
<p>En C# lo serán a aquellas funciones que reciban o devuelvan un delegado, o ambas cosas.</p>
<ol>
<li>
<p>Reciben un delegado...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> func1 <span class="token operator">=</span> d <span class="token operator">=&gt;</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token class-name">Func<span class="token punctuation">&lt;</span>Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> func2 <span class="token operator">=</span> <span class="token punctuation">(</span>func<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// func2 es una HOF</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span></span> a <span class="token operator">=</span> <span class="token function">func2</span><span class="token punctuation">(</span>func1<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a = func1(3) + 2 = (3 + 1) + 2 = 6</span>
</code></pre></li>
<li>
<p>Devuelven un delegado...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> suma <span class="token operator">=</span> op1 <span class="token operator">=&gt;</span> op2 <span class="token operator">=&gt;</span> op1 <span class="token operator">+</span> op2<span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span></span> a <span class="token operator">=</span>  <span class="token function">suma</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a = (op2 =&gt; 3 + op2)(2) = 3 + 2 = 5</span>
</code></pre></li>
</ol>
</blockquote>
<p>Veamos un par de ejemplo de uso de este concepto de clausura con una utilidad más concreta pero simplemente para que terminemos de entender el concepto y la terminología ...</p>
<div style="page-break-after:always;"></div>
<p><strong>Ejemplo 1:</strong> Definiremos una HOF <strong><code>Contador()</code></strong> que me devuelva una clausura que al llamarla me devuelva un contador capturado incrementado.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> <span class="token function">Contador</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token comment">// Devuelvo la clausura que captura el contador i..</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// Cada cuenta captura una variable i local diferente por lo que </span>
    <span class="token comment">// llevarán cuentas independientes</span>
    <span class="token class-name"><span class="token keyword keyword-var">var</span></span> cuenta1 <span class="token operator">=</span> <span class="token function">Contador</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Creo un contador</span>
    <span class="token class-name"><span class="token keyword keyword-var">var</span></span> cuenta2 <span class="token operator">=</span> <span class="token function">Contador</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Creo un segundo contador contador</span>

    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">cuenta1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Muestra 1</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">cuenta2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Muestra 1 por ser otro contador</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">cuenta2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Muestra 2</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">cuenta2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Muestra 3</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">cuenta1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Muestra 2</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>Ejemplo 2:</strong> Definiremos una HOF <strong><code>Potencia(double y)</code></strong> que me permita definir otras funciones que calculen potencias con un</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">Ejemplo</span>
<span class="token punctuation">{</span>
    <span class="token comment">// HOF que devuelve una clausura que captura el parámetro de entrada 'y'.</span>
    <span class="token comment">// Fíjate que estemos definiendo un cuerpo de expresión que se evalúa una </span>
    <span class="token comment">// clausura que dada una base 'x' calcula 'x' elevado a la variable capturada 'y'.</span>
    <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">&gt;</span></span> <span class="token function">Potencia</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-double">double</span></span> y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">=&gt;</span> Math<span class="token punctuation">.</span><span class="token function">Pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Definimos una función que calcula cuadrados pasándole el exponente a capturar.</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-readonly">readonly</span> <span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">&gt;</span></span> Cuadrado <span class="token operator">=</span> <span class="token function">Potencia</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Definición análoga para capturar el cubo.</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-readonly">readonly</span> <span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">&gt;</span></span> Cubo <span class="token operator">=</span> <span class="token function">Potencia</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Cuadrado</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x = 10 elevado a y = 2 mostrará 100</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Cubo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// x = 10 elevado a y = 3 mostrará 1000</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div style="page-break-after:always;"></div>
<p>Si vamos al principio del tema donde definíamos lo que era la programación funcional, decíamos que:</p>
<blockquote>
<p>'<em>La <strong>programación funcional</strong> es un <strong>paradigma de programación declarativa</strong> basado</em>' ...</p>
</blockquote>
<p>Para entender un poco mejor a que se refiere con '<em>programación declarativa</em>', vamos a comparar y resumir de forma sencilla la diferencia entre la programación imperativa y declarativa. Diremos que, en la <strong>imperativa</strong> le decimos nosotros al ordenador <strong>'<em>cómo tiene que hacer algo</em>'</strong> mediante una secuencia de instrucciones que sería más o menos lo que hemos hecho hasta ahora. Sin embargo, en la <strong>declarativa</strong> le decimos al ordenador <strong>'<em>lo que tiene que hacer</em>'</strong>, proporcionándole únicamente las estrategias para hacerlo. Por poner un ejemplo, el lenguaje SQL sería claramente declarativo ya que en él, le decimos al SGBD por ejemplo que seleccione n-tuplas que cumplan un criterio y les aplique una estrategia de agrupación, pero <strong>'<em>no le indicamos cómo tiene que hacerlo</em>'</strong>, de hecho no sabemos cómo lo hace internamente.</p>
<p>Sin entrar en aspectos más teóricos o formales matemáticos como quizá hemos hecho al hablar del λ-cálculo, diremos que la gran mayoría de lenguajes modernos proporcionan una serie de métodos para trabajar sobre secuencias de datos de forma similar a cómo lo haríamos en SQL aplicando programación funcional.</p>
<p>En C# estos métodos para trabajar con secuencias (<strong><code>IEnumerable&lt;T&gt;</code></strong>) están definidos como <a href="https://docs.microsoft.com/es-es/dotnet/api/system.linq.enumerable">métodos de extensión</a> en <strong><code>System.Linq</code></strong> como ya comentamos al hablar de este tipo de métodos.</p>
<p>Entre ellos podremos destacar: <strong><code>Select</code></strong>, <strong><code>Where</code></strong>, <strong><code>Agreggate</code></strong>, <strong><code>GroupBy</code></strong>, <strong><code>Distinct</code></strong>, <strong><code>ElementAt</code></strong>, <strong><code>Join</code></strong>, <strong><code>GroupJoin</code></strong>, <strong><code>OrderBy</code></strong>, <strong><code>Reverse</code></strong>, <strong><code>SelectMany</code></strong>, etc.</p>
<div style="page-break-after:always;"></div>
<h3 id="patrón-map-filter-fold">Patrón Map-Filter-Fold </h3>
<p>Es un patrón funcional utilizado en numerosos lenguajes tan populares como JavaScriprt(&gt;ES6), Java(&gt;8), C#, Python, Scala, Swift, Kotlin, etc y que permite hacer operaciones declarativas sobre secuencias de elementos de forma análoga a SQL.</p>
<blockquote>
<p>📌 <strong>Nota 1:</strong> Detrás de este patrón hay una gran teoría matemática aunque nosotros la vamos a obviar y vamos a tratar de explicar las operaciones de forma más didáctica. Si quieres profundizar en el tema puedes seguir los enlaces en el tema.</p>
</blockquote>
<blockquote>
<p>📌 <strong>Nota 2:</strong> Durante el resto del tema vamos a utilizar la siguiente notación para representar secuencias (colecciones) y objetos...</p>
<ul>
<li><strong>Corchetes</strong> para secuencias <strong>[</strong> e1, e2, e3, ..., en <strong>]</strong> o <strong>Sec[</strong> e1, e2 <strong>]</strong></li>
<li><strong>Llaves</strong> para objetos <strong>{</strong> Propiedad1=valor1, Porpiedad2=valor2 <strong>}</strong></li>
</ul>
</blockquote>
<h4 id="map-o-select">Map (o Select) </h4>
<p><strong><a href="https://en.wikipedia.org/wiki/Map_(higher-order_function)">Map</a></strong> es una HOF que aplica una función única de '<em>mapeo</em>' o <strong>transformación</strong> a cada elemento de la secuencia y devuelve una nueva secuencia que contiene los resultados de la transformación en el mismo orden de la secuencia de entrada.</p>
<p>A lo largo de este tema vamos a ejemplificar los conceptos de forma genérica con emojis, porque realmente es un concepto abstracto y estos nos ayudarán a entender la abstracción de forma didáctica.<br>
Supongamos que representamos <strong>map</strong> con la expresión <strong>map = (A → B) × Sec[A] → Sec[B]</strong> donde:</p>
<ul>
<li><strong>A</strong> son productos en crudo o sin procesar.<br>
Ej. el maíz 🌽.</li>
<li><strong>B</strong> son productos cocinados o procesados.<br>
Ej. las palomitas de maíz 🍿.</li>
<li><strong>A → B</strong> sería la función que cocina o <strong>transforma</strong> un producto en crudo en un producto cocinado y la podemos llamar por ejemplo <strong>cook</strong>. Esta función se pasará como parámetro a la función <strong>map</strong> (por eso <strong>map</strong> es una HOF).<br>
Ej. <strong>cook(🌽) → 🍿</strong>.</li>
<li><strong>Sec[A]</strong> seria la secuencia de <strong>entrada</strong> de la función <strong>map</strong> de productos en crudo.<br>
Ej. [🐮, 🐟, 🍠, 🐔, 🌽]</li>
<li><strong>Sec[B]</strong> seria la secuencia de <strong>salida</strong> de la función <strong>map</strong> de productos ya cocinados o procesados por la función <strong>cook</strong>.<br>
Ej. [🍔, 🍥, 🍟, 🍗, 🍿]</li>
</ul>
<p>Con lo cual podríamos decir que, <strong>map = cook × ProductosCrudos → ProductosCocinados</strong>. Esto es, map dada una secuencia de productos en crudo le aplica a cada producto la <strong>función de transformación</strong> cocinar y me dará como resultado una secuencia de productos cocinados.<br>
Ej. <strong>[🐮, 🐟, 🍠, 🐔, 🌽].map(cook) → [🍔, 🍥, 🍟, 🍗, 🍿]</strong></p>
<p>En C# lo aplicaremos a través del método extensor <strong><a href="https://docs.microsoft.com/es-es/dotnet/api/system.linq.enumerable.select">Select</a></strong> ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Se aplica a secuencia de entrada IEnumerable&lt;A&gt;</span>
<span class="token comment">// A cada elemento de la secuencia de entrada se le aplica el 'mapeo' A =&gt; B</span>
<span class="token comment">// Retorna una secuencia de salida IEnumerable&lt;B&gt; con los </span>
<span class="token comment">// elementos de la secuencia de entrada mapeados.</span>
<span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>B<span class="token punctuation">&gt;</span></span> <span class="token generic-method"><span class="token function">Select</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>A<span class="token punctuation">,</span> B<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword keyword-this">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>A<span class="token punctuation">&gt;</span></span> source<span class="token punctuation">,</span> <span class="token class-name">Func<span class="token punctuation">&lt;</span>A<span class="token punctuation">,</span> B<span class="token punctuation">&gt;</span></span> mapeoDeAenB<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Veamos su uso a través de un ejemplo sencillo donde transformamos una secuencia de números reales en su equivalente entero. '<em>Mapeando</em>' de real a entero cada uno de elementos de la secuencia de entrada.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Dada la siguiente secuencia de números reales</span>
<span class="token class-name"><span class="token keyword keyword-double">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> reales <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">8.7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Aplicamos la función ToInt32 que cumple con el tipo delegado Func&lt;double, int&gt;</span>
<span class="token comment">// para transformar la secuencia a enteros.</span>
<span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> enteros <span class="token operator">=</span> reales<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>Convert<span class="token punctuation">.</span>ToInt32<span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">,</span> enteros<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h4 id="filter-o-where">Filter (o Where) </h4>
<p><strong><a href="https://en.wikipedia.org/wiki/Filter_(higher-order_function)">Filter</a></strong> es una HOF que aplica un predicado a cada elemento de la secuencia de entrada y devuelve una secuencia de salida con los elementos en la secuencia que cumplen el predicado.</p>
<p>Supongamos que representamos <strong>filter</strong> con la expresión <strong>filter = (A → bool) × Sec[A] → Sec[A']</strong> donde:</p>
<ul>
<li><strong>A</strong> son productos cocinados o preparados.<br>
Ej. una hamburguesa 🍔.</li>
<li><strong>A → bool</strong> sería el predicado que evalúa si los elementos de <strong>A</strong> cumplen un determinado criterio o no. Este predicado se pasará como parámetro a la función <strong>filter</strong>.<br>
Ej. <strong>isVegetarian(🍔) → false</strong>.</li>
<li><strong>Sec[A]</strong> seria la secuencia de <strong>entrada</strong> de la función <strong>filter</strong> de productos ya cocinados.<br>
Ej.  [🍔, 🍥, 🍟, 🍗, 🍿]</li>
<li><strong>Sec[A']</strong> seria la secuencia de <strong>salida</strong> de la función <strong>filter</strong> de productos ya cocinados que cumplen el predicado <strong>isVegetarian</strong>, esto es, <em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A' \subseteq A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></em>.<br>
Ej. [🍟, 🍿]</li>
</ul>
<p>Con lo cual podríamos decir que, <strong>filter = isVegetarian × ProductosCocinados → ProductosCocinadosVegetarianos</strong>. Esto es, filter dada una secuencia de productos ya cocinados me devolverá aquellos que sean vegetarianos.<br>
Ej. <strong>[🍔, 🍥, 🍟, 🍗, 🍿].filter(isVegetarian) → [🍟, 🍿]</strong></p>
<p>En C# lo aplicaremos a través del método extensor <strong><a href="https://docs.microsoft.com/es-es/dotnet/api/system.linq.enumerable.where">Where</a></strong> ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Dada la siguiente secuencia de enteros.</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> enteros <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Filtramos aquellos que sean pares...</span>
<span class="token comment">// 1. Definimos el predicado para ver si un número es par.</span>
<span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-bool">bool</span><span class="token punctuation">&gt;</span></span> esPar <span class="token operator">=</span> n <span class="token operator">=&gt;</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token comment">// 2. Aplicamos el predicado a la función where</span>
<span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> enterosPares <span class="token operator">=</span> enteros<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>esPar<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">,</span> enterosPares<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h4 id="fold-o-aggregate">Fold (o Aggregate) </h4>
<p><strong><a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">Fold</a></strong> es una HOF también conocida como <strong>reduce</strong>, <strong>aggregate</strong>, <strong>accumulate</strong>, etc. que '<em>combina</em>' los elementos de la secuencia de entrada reduciéndolos a un único elemento de retorno. Para obtener este elemento de retorno necesitaremos una función binaria que combine los elementos de la secuencia en dicho elemento de retorno que normalmente tendrá un estado inicial.</p>
<p>Supongamos que representamos <strong>fold</strong> con la expresión <strong>fold = (B × A → B) × Sec[A] × B → B</strong> donde:</p>
<ul>
<li>
<p><strong>B</strong> es el elemento de retorno el cual tomará un valor inicial.<br>
Ej. Pepe que <strong>inicialmente</strong> está hambriento y cansado 😫 pero puede tener otros estados como satisfecho 😋</p>
</li>
<li>
<p><strong>A</strong> son los productos cocinados o preparados.<br>
Ej. la hamburguesa de vacuno 🍔</p>
</li>
<li>
<p><strong>Sec[A]</strong> obviamente es una secuéncia de productos cocinados o preparados.<br>
Ej. [🍔, 🍥, 🍟, 🍗, 🍿]</p>
</li>
<li>
<p><strong>B × A → B</strong> función binaria que combina <strong>B</strong> con <strong>A</strong> y se evalúa a <strong>B</strong>.<br>
Ej. En nuestro ejemplo, esta función de combinación puede ser <strong>eat(😫, 🍔) → 😋</strong> donde el resultado de combinar a 😫(Pepe hambriento) con la 🍔 (hamburguesa) sería 😋(Pepe satisfecho). Ojo!, que también puede pasar que al comer (combinar), el estado de pepe no cambie y siga hambriento <strong>eat(😫, 🍔) → 😫</strong></p>
<blockquote>
<p>💡 <strong>Tip:</strong> En otras palabras, <strong>eat</strong> es una función de plegado (<strong>fold</strong>), reducción (<strong>reduce</strong>), agregación (<strong>aggregate</strong>), etc. de la hamburguesa sobre Pepe y que me da como resultado al propio Pepe con menos hambre o saciado...</p>
</blockquote>
</li>
</ul>
<p>Con lo cual podríamos decir que, <strong>fold = come × ProductosCocinados × PepeHambriento → PepeSatisfecho</strong>. Esto es, fold dado un Pepe hambriento y una secuencia de productos cocinados, me devolverá un Pepe satisfecho.<br>
Ej. <strong>[🍟, 🍿].fold(😫, eat) → 😋</strong></p>
<p>En C# lo aplicaremos a través de las sobrecargas del método extensor <strong><a href="https://docs.microsoft.com/es-es/dotnet/api/system.linq.enumerable.aggregate">Aggregate</a></strong> ...</p>
<blockquote>
<p>📌 <strong>Nota:</strong> <strong><code>System.Linq</code></strong> nos proporciona muchas funciones de agregación ya implementadas como métodos de extension sobre secuencias tales como: <strong>Sum</strong>, <strong>Max</strong>, <strong>Min</strong>, <strong>Average</strong>, o <strong>Count</strong>.</p>
</blockquote>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Dada la siguiente secuencia de notas enteras</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> notas <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Cuenta las notas mayores o iguales a 5.</span>
<span class="token comment">// 1. Definimos la función binaria de agregación que vamos apasar a Aggregate....</span>
<span class="token comment">//    c -&gt; Es el contador.</span>
<span class="token comment">//    n -&gt; Es un elemento de la secuencia (una nota).</span>
<span class="token comment">//    Se evalúa a la cuenta incremetada o sin incrementar dependiendo de</span>
<span class="token comment">//    si nota &gt;= 5 o no.</span>
<span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">&gt;</span></span> cuentaAprobados <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">&gt;=</span> <span class="token number">5</span> <span class="token punctuation">?</span> c <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">:</span> c<span class="token punctuation">;</span>

<span class="token comment">// 2. Aplicamos la HOF de agregación, pasándole el valor inicial de la cuenta y </span>
<span class="token comment">//    la función agregadora.</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span></span> aprobados <span class="token operator">=</span> notas<span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cuentaAprobados<span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Total aprobados: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">aprobados</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><strong><code>Aggregate</code></strong> por defecto recorrerá la secuencia de izquierda a derecha y para el caso anterior de contar aprobados nos daría igual. Sin embargo, muchos lenguajes funcionales ofrecen ambas posibilidades:</p>
<ul>
<li><strong><code>foldl</code></strong>: (fold left) Recorre como <strong><code>Aggregate</code></strong> de izquierda a derecha.</li>
<li><strong><code>foldr</code></strong>: (fold right) Recorre la secuencia de derecha a izquierda.</li>
</ul>
<p>Veamos una ejemplo de como hacerlo en C#. Para ello, vamos a suponer que queremos implementar el método de utilidad definido en la clase <strong><code>String</code></strong> y que hemos usado muchas veces a lo largo del curso. <strong><code>string.Join(string? separador, IEnumerable&lt;string?&gt; textos)</code></strong>.</p>
<p>Si nos fijamos cumple con <strong>(B × A → B) × Sec[A] × B → B</strong> pero ahora no obtendremos el mismo resultado si hacemos <strong><code>foldl</code></strong> o <strong><code>foldr</code></strong> ...</p>
<ul>
<li>
<p><strong>A</strong> Serán una palabra (<strong><code>String</code></strong>) a concatenar.</p>
</li>
<li>
<p><strong>Sec[A]</strong> Será la secuencia de palabras a concatenar.</p>
</li>
<li>
<p><strong>B</strong> Ahora el tipo <em>'agregador'</em> sería un <strong><code>StringBuilder</code></strong> donde vamos a concatenar todas las palabras con el separador adecuado.</p>
<ol>
<li>Valor inicial será <strong><code>new StringBuilder(palabras.Length &gt; 0 ? palabras.First() : ""</code></strong>, esto es, un <strong><code>StringBuilder</code></strong> vacío si la secuencia esta vacía o uno que contenga la primera palabra de la misma si contiene alguna.</li>
<li>Valor final será el <strong><code>StringBuilder</code></strong> inicial <strong><code>B</code></strong> al que le he concatenado todas las palabras por la derecha.</li>
</ol>
</li>
<li>
<p><strong>(B × A → B)</strong> La función binaria de agregación será de tipo <strong><code>Func&lt;StringBuilder, string, StringBuilder&gt;</code></strong> y recibirá el <strong><code>StringBuilder</code></strong> <strong><code>B</code></strong> con lo que llevo de la cadena concatenada, la siguiente palabra <strong>A</strong> a concatenar con el separador y retornará el <strong><code>StringBuilder</code></strong> <strong>B</strong> con la palabra concatenada por la derecha.</p>
</li>
</ul>
<blockquote>
<p>📣 <strong>Resumen:</strong> Podemos resumir de forma simple que <strong><code>Join</code></strong> se comporta como <strong><code>foldl</code></strong> porque entra una secuencia de cadenas y devuelve un único tipo resultado de concatenar las cadenas con un separador determinado.<br>
La única diferencia es que <strong><code>Join</code></strong> devuelve un <strong><code>string</code></strong> y nosotros vamos a devolver un <strong><code>StringBuilder</code></strong> por eficiencia.</p>
</blockquote>
<p>Veamos pues nuestra propuesta de implementación de <strong><code>Join</code></strong> con un <strong><code>Aggregate</code></strong> (<strong><code>foldr</code></strong>) en C# ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Definimos la secuencia</span>
<span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> palabras <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"Once"</span><span class="token punctuation">,</span> <span class="token string">"upon"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"time"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Definimos el separador que será una variable capturada en la función lambda.</span>
<span class="token keyword keyword-const">const</span> <span class="token class-name"><span class="token keyword keyword-string">string</span></span> separador <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">;</span>

<span class="token comment">// Función lambda agregadora concatena...</span>
<span class="token comment">//  Si la palabra a concatenar no es nula y no coincide con el valor inicial de la </span>
<span class="token comment">//  concatenación o en otras palabras es la primera palabra de la secuencia la </span>
<span class="token comment">//  concatenamos con el valor del separador capturado.</span>
<span class="token class-name">Func<span class="token punctuation">&lt;</span>StringBuilder<span class="token punctuation">,</span> <span class="token keyword keyword-string">string</span><span class="token punctuation">,</span> StringBuilder<span class="token punctuation">&gt;</span></span> concatena <span class="token operator">=</span> 
<span class="token punctuation">(</span>f<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> f<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword keyword-null">null</span> <span class="token operator">&amp;&amp;</span> f<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> p <span class="token punctuation">?</span> <span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">separador</span><span class="token punctuation">}</span></span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">p</span><span class="token punctuation">}</span></span><span class="token string">"</span></span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">StringBuilder</span> frase <span class="token operator">=</span> palabras<span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span>
                        <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span>palabras<span class="token punctuation">.</span>Length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">?</span> palabras<span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                        concatena<span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>frase<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mostrará "Once upon a time"</span>
</code></pre><p>pero...¿y si quisiéramos hacer un <strong><code>foldr</code></strong> en C#?. Sería '<em>tan simple</em>' como <strong>invertir la secuencia de entrada</strong> con <strong><code>Reverse()</code></strong> y el lugar de tomar la primera ocurrencia (<strong><code>First</code></strong>) de la secuencia para inicializar nuestro <strong><code>StringBuilder</code></strong>, tomaríamos la última <strong><code>Last</code></strong>.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name">StringBuilder</span> frase <span class="token operator">=</span> palabras
                    <span class="token punctuation">.</span><span class="token function">Reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span>
                        <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span>palabras<span class="token punctuation">.</span>Length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">?</span> palabras<span class="token punctuation">.</span><span class="token function">Last</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                        concatena<span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>frase<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mostrará "time a upon Once"</span>
</code></pre><p><strong><code>Aggregate</code></strong> además tiene varias sobrecargas y vamos a comentar una de ellas que nos puede ser interesante en este caso.</p>
<p>Si vamos a ver la definición de <strong><code>Aggregate</code></strong> para el uso anterior tendremos el siguiente interfaz que ya deberíamos entender...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// TSource es la parametrización de A</span>
<span class="token comment">// TAccumulate es la parametrización de B</span>
<span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">TResult</span> <span class="token generic-method"><span class="token function">Aggregate</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">,</span> TAccumulate<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>
        <span class="token keyword keyword-this">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> source<span class="token punctuation">,</span>               <span class="token comment">// Sec[A]</span>
        <span class="token class-name">TAccumulate</span> seed<span class="token punctuation">,</span>                               <span class="token comment">// B (inicial)</span>
        <span class="token class-name">Func<span class="token punctuation">&lt;</span>TAccumulate<span class="token punctuation">,</span> TSource<span class="token punctuation">,</span> TAccumulate<span class="token punctuation">&gt;</span></span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// B × A → B</span>
</code></pre><p>Sin embargo, tenemos también la sobrecarga ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">TResult</span> <span class="token generic-method"><span class="token function">Aggregate</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">,</span> TAccumulate<span class="token punctuation">,</span> TResult<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>
        <span class="token keyword keyword-this">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> source<span class="token punctuation">,</span> 
        <span class="token class-name">TAccumulate</span> seed<span class="token punctuation">,</span> 
        <span class="token class-name">Func<span class="token punctuation">&lt;</span>TAccumulate<span class="token punctuation">,</span> TSource<span class="token punctuation">,</span> TAccumulate<span class="token punctuation">&gt;</span></span> func<span class="token punctuation">,</span> 
        <span class="token class-name">Func<span class="token punctuation">&lt;</span>TAccumulate<span class="token punctuation">,</span> TResult<span class="token punctuation">&gt;</span></span> resultSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>donde aparece otra nuevo tipo parametrizado <strong><code>TResult</code></strong> y función de entrada <strong><code>Func&lt;TAccumulate, TResult&gt; resultSelector</code></strong> que una vez realizado todo el proceso de <strong>'<em>fold</em>'</strong> me transformará (mapeará) mi <strong><code>TAccumulate</code></strong> final en un <strong><code>TResult</code></strong>.</p>
<p>En nuestro ejemplo, al definir el <strong><code>TAccumulate</code></strong> como un <strong><code>StringBuilder</code></strong> por optimización, el resultado del <strong><code>Aggregate</code></strong> será un <strong><code>StringBuilder</code></strong> y no un <strong><code>string</code></strong> como nos proporcionaría el <strong><code>string.Join(...)</code></strong>. Pero la función de mapeo <strong><code>Func&lt;TAccumulate, TResult&gt; resultSelector</code></strong> nos permitirá convertir el <strong><code>StringBuilder</code></strong> a un <strong><code>string</code></strong> con <strong><code>sb =&gt; sb.ToString()</code></strong> y será lo que terminará devolviendo <strong><code>Aggregate</code></strong>.</p>
<p>Nuestra expresión equivalente al <strong><code>Join</code></strong> haciendo un <strong><code>Aggregate</code></strong> (<strong><code>foldl</code></strong>) finalmente quedaría ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> palabras <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"Once"</span><span class="token punctuation">,</span> <span class="token string">"upon"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"time"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> <span class="token class-name"><span class="token keyword keyword-string">string</span></span> separador <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">;</span>

<span class="token comment">// Con Join</span>
<span class="token class-name"><span class="token keyword keyword-string">string</span></span> frase <span class="token operator">=</span> <span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>separador<span class="token punctuation">,</span> palabras<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Con Aggregate</span>
<span class="token class-name"><span class="token keyword keyword-string">string</span></span> frase <span class="token operator">=</span> palabras<span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span>
    <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span>palabras<span class="token punctuation">.</span>Length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">?</span> palabras<span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    <span class="token punctuation">(</span>f<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> f<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> p <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token keyword keyword-null">null</span> <span class="token punctuation">?</span> <span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">separador</span><span class="token punctuation">}</span></span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">p</span><span class="token punctuation">}</span></span><span class="token string">"</span></span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    sb <span class="token operator">=&gt;</span> sb<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>frase<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><blockquote>
<p>✋ <strong>Importante:</strong> Fíjate que en esta ocasión hemos pasado las funciones de agregación y mapeo directamente a <strong><code>Aggregate</code></strong> en lugar de asignarlas previamente a un delegado. Esto es posible porque <strong>C# es capaz de deducir los tipos</strong> de <strong><code>(f, p) =&gt;</code></strong> y de <strong><code>sb =&gt;</code></strong> a partir del tipo de la secuencia <strong><code>palabras</code></strong> y el tipo del objeto que le pasamos como acumulador.</p>
</blockquote>
<blockquote>
<p>📌 <strong>Nota:</strong> Obviamente en este caso, es muchísimo más simple utilizar la función ya implementada <strong><code>Join</code></strong>. Pero hemos puesto este ejemplo, además de para ver el concepto de <strong><code>foldl</code></strong> y <strong><code>foldr</code></strong>, para entender la potencia de esta función si entendemos bien lo potente que es esta operación conceptualmente.<br>
De momento la hemos usado para cosas tan diferentes como: que Pepe coma 😋, contar aprobados o concatenar palabras con un separador.</p>
</blockquote>
<h4 id="combinando-las-tres-operaciones">Combinando las tres operaciones </h4>
<p>Podemos combinar dichas operaciones para realizar nuestro proceso en una única función de forma declarativa.</p>
<p>Imaginemos nuestro ejemplo en que queremos alimentar a Pepe, que recordemos que es vegetariano y partimos de un montón de productor en crudo. Podríamos hacer...</p>
<p><strong>[🐮, 🐟, 🍠, 🐔, 🌽].map(cook).filter(isVegetarian).fold(😫, eat) → 😋</strong></p>
<p>Esto equivaldría a las operaciones anteriores de forma encadenada. Donde la secuencia de salida de una función pasa a ser la de entrada de la siguiente [🐮, 🐟, 🍠, 🐔, 🌽] → [🍔, 🍥, 🍟, 🍗, 🍿] → [🍟, 🍿] → 😋</p>
<p>Sin embargo es importante preguntarnos si el orden de aplicación es eficiente. Fíjate que en este caso, hemos tenido que <em>'cocinar'</em> todos los alimentos aunque realmente Pepe solo se ha comido dos de ellos. Este proceso hubiera sido muchísimo más eficiente si hubieramos cocinado solo aquellos que <em>'son vegetales'</em> [🐮, 🐟, 🍠, 🐔, 🌽] → [🍠, 🌽] → [🍟, 🍿] → 😋, esto es, haciendo el filtrado antes que la transformación ...</p>
<p><strong>[🐮, 🐟, 🍠, 🐔, 🌽].filter(isVegetarian).map(cook).fold(😫, eat) → 😋</strong></p>
<blockquote>
<p>📌 <strong>Nota:</strong> Esto último sería posible solo si la función de filtrado ahora tuviese como conjunto <strong>A</strong> a los productos crudos o una <strong>abstracción</strong> de ambos,  es decir, si se pudiera saber si un productos '<strong>es vegetal</strong>' independientemente de si está cocinado o no <strong>isVegetarian(🌽) → true</strong> y <strong>isVegetarian(🍿) → true</strong></p>
</blockquote>
<p><strong>Ejemplo:</strong> Imaginemos que queremos saber el total de aprobados de una lista de notas con decimales.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Select (map):      Transforma de double a double sin decimales. </span>
<span class="token comment">//                    Puesto que Math.Round tiene varias sobrecargas, deberemos indicar </span>
<span class="token comment">//                    mediante un cast que queremos una función del tipo A → B</span>
<span class="token comment">//</span>
<span class="token comment">// Where (filter):    Filtramos aquellas notas que que cumplen el predicado n &gt;= 5d</span>
<span class="token comment">//</span>
<span class="token comment">// Aggregate (fold):  Vamos a llevar una cuenta en c empezando en 0d y al final del proceso </span>
<span class="token comment">//                    convertimos la cuenta real en un valor entero. Esto último no sería </span>
<span class="token comment">//                    necesario, si el valor inicial de la cuenta hubiera sido un literal </span>
<span class="token comment">//                    entero, pero lo hacemos así para ves un ejemplo de uso de resultSelector.</span>

<span class="token class-name"><span class="token keyword keyword-double">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> notas <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">6.7</span><span class="token punctuation">,</span> <span class="token number">8.7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span></span> aprobados <span class="token operator">=</span> notas<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Func<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span>Round<span class="token punctuation">)</span>
                     <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> n <span class="token operator">&gt;=</span> <span class="token number">5d</span><span class="token punctuation">)</span>
                     <span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span><span class="token number">0d</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>c<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c <span class="token operator">=&gt;</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Aprobados: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">aprobados</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Puesto que cosas como contar elementos en usa secuencia, acumular en una suma, buscar un máximo, etc. son casos típicos de fold, ya vienen predefinidos en C# y no tendríamos que implementarlos a través de Aggregate</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-int">int</span></span> aprobados <span class="token operator">=</span> notas<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Func<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span>Round<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> n <span class="token operator">&gt;=</span> <span class="token number">5d</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Fíjate que es bastante similar a SQL, una posible consulta para hacer lo mismo en SQL.</p>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token function">ROUND</span><span class="token punctuation">(</span>nota<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> aprobados <span class="token keyword keyword-FROM">FROM</span> notas <span class="token keyword keyword-where">where</span> <span class="token function">ROUND</span><span class="token punctuation">(</span>nota<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre><p>En este caso no podemos filtrar antes de hacer el mapeo puesto que el resultado sería diferente. Piensa que <strong><code>4.6</code></strong> después del <strong><code>Round</code></strong> será <strong><code>5</code></strong> y contará como aprobado.</p>
<div style="page-break-after:always;"></div>
<blockquote>
<p>🚀 <strong>Ampliación:</strong></p>
<p>Cómo hemos dicho este patrón existirá de forma similar en otros lenguajes y seguramente sin saber la sintaxis de otros lenguajes seguramente podemos entender el código equivalente en lenguajes tan populares como:</p>
<p><strong>JavaScript:</strong></p>
<pre data-role="codeBlock" data-info="JavaScript" class="language-javascript JavaScript"><code><span class="token keyword keyword-let">let</span> notas <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">6.7</span><span class="token punctuation">,</span> <span class="token number">8.7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword keyword-let">let</span> aprobados <span class="token operator">=</span> notas<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token property-access">round</span><span class="token punctuation">)</span>
                     <span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token parameter">n</span> <span class="token arrow operator">=&gt;</span> n <span class="token operator">&gt;=</span> <span class="token number">5</span><span class="token punctuation">)</span>
                     <span class="token punctuation">.</span><span class="token method function property-access">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">write</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Aprobados: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>aprobados<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><strong>Kotlin:</strong></p>
<pre data-role="codeBlock" data-info="Kotlin" class="language-kotlin Kotlin"><code><span class="token keyword keyword-val">val</span> notas <span class="token operator">=</span> <span class="token function">doubleArrayOf</span><span class="token punctuation">(</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">6.7</span><span class="token punctuation">,</span> <span class="token number">8.7</span><span class="token punctuation">)</span>
<span class="token keyword keyword-val">val</span> aprobados <span class="token operator">=</span> notas<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
                     <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> it <span class="token operator">&gt;=</span> <span class="token number">5</span> <span class="token punctuation">}</span>
                     <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> acc<span class="token punctuation">,</span> _ <span class="token operator">-&gt;</span> acc <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Aprobados: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">aprobados</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre><p><strong>Python:</strong></p>
<pre data-role="codeBlock" data-info="Python" class="language-python Python"><code><span class="token keyword keyword-from">from</span> functools <span class="token keyword keyword-import">import</span> <span class="token builtin">reduce</span>
notas <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">6.7</span><span class="token punctuation">,</span> <span class="token number">8.7</span><span class="token punctuation">]</span>
aprobados <span class="token operator">=</span> <span class="token builtin">reduce</span><span class="token punctuation">(</span><span class="token keyword keyword-lambda">lambda</span> c<span class="token punctuation">,</span> n<span class="token punctuation">:</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> 
                    <span class="token builtin">filter</span><span class="token punctuation">(</span><span class="token keyword keyword-lambda">lambda</span> n<span class="token punctuation">:</span> n <span class="token operator">&gt;=</span> <span class="token number">5</span><span class="token punctuation">,</span> 
                            <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">round</span><span class="token punctuation">,</span> notas<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
            <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword keyword-print">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Aprobados: </span><span class="token interpolation"><span class="token punctuation">{</span>aprobados<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
</code></pre></blockquote>
<div style="page-break-after:always;"></div>
<h3 id="otras-operaciones-funcionales-declarativas-en-c">Otras operaciones funcionales declarativas en C# </h3>
<p>Ya hemos visto que <strong><code>Select</code></strong>, <strong><code>Where</code></strong>, <strong><code>Aggregate</code></strong>, <strong><code>Count</code></strong> y sin duda estas operaciones como hemos mencionado nos deben <em>'sonar'</em> de SQL. Pero..., ¿Existen otras operaciones equivalentes a las que podemos encontrar en SQL?.</p>
<p>la respuesta es <strong>sí</strong> y vamos ver algunas de ellas ...</p>
<h4 id="orderbyorderbydescending">OrderBy/OrderByDescending </h4>
<p>Ordena de manera ascendente/descendente los elementos de una secuencia en función de una clave.</p>
<blockquote>
<p>📌 <strong>Nota:</strong> Los tipos deben ser <strong>comparables</strong>. Si no lo son, necesitará de un objeto que implemente el interfaz <strong><code>IComparer&lt;T&gt;</code></strong> entre dos elementos del tipo de la clave por la que hemos decidido ordenar.</p>
</blockquote>
<h4 id="distinct">Distinct </h4>
<p>Elimina valores repetidos en una secuencia.</p>
<blockquote>
<p>📌 <strong>Nota:</strong> El tipo de datos de la secuencia deberá implementar <strong><code>IEquatable</code></strong> para poder comparar en igualdad los elemento de la secuencia o deberemos pasarle un objeto que implemente un interfaz de comparación.</p>
</blockquote>
<p><strong>Ejemplo:</strong> Imaginemos que queremos saber la mayor nota redondeada de la siguiente secuencia...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-double">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> notas <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">7.2</span><span class="token punctuation">,</span> <span class="token number">7.6</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">8.7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>Podíamos usar un <strong><code>Aggregate</code></strong> para obtener el máximo o usar la función <strong><code>Max</code></strong> que hace la operación específica de la siguiente forma.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-int">int</span></span> notaMayor <span class="token operator">=</span> notas<span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span>
                        <span class="token keyword keyword-double">double</span><span class="token punctuation">.</span>MinValue<span class="token punctuation">,</span> 
                        <span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">&gt;</span> <span class="token class-name">m <span class="token punctuation">?</span></span> n <span class="token punctuation">:</span> m<span class="token punctuation">,</span> 
                        n <span class="token operator">=&gt;</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Round</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// o también                         </span>
<span class="token class-name"><span class="token keyword keyword-int">int</span></span> notaMayor <span class="token operator">=</span> notas<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Round</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"La nota redondeada mayor es </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">notaMayor</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>En este caso también sería bastante similar a un posible consulta en SQL.</p>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token function">ROUND</span><span class="token punctuation">(</span>nota<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> notaMayor <span class="token keyword keyword-FROM">FROM</span> notas<span class="token punctuation">;</span>
</code></pre><p>Aunque más ineficiente, también podríamos usar <strong><code>Distinct</code></strong> y <strong><code>OrderBy</code></strong> de la siguiente manera ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-double">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> notas <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">7.2</span><span class="token punctuation">,</span> <span class="token number">7.6</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">8.7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span></span> notaMayor <span class="token operator">=</span> notas<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Round</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   
                      <span class="token comment">// 1. Redondeamos las notas de la secuencia a su valor entero.</span>
                      <span class="token punctuation">.</span><span class="token function">Distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                    
                      <span class="token comment">// 2. Eliminamos de la secuencia las notas repetidas.</span>
                      <span class="token punctuation">.</span><span class="token function">OrderByDescending</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> n<span class="token punctuation">)</span>                     
                      <span class="token comment">// 3. Ordenamos la secuencia de en orden descendiente, esto es, </span>
                      <span class="token comment">// la nota mayor es la primera.</span>
                      <span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      
                      <span class="token comment">// 4. Obtenemos el primer elemento de la secuencia.</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"La nota redondeada mayor es </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">notaMayor</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Fíjate que aunque es un poco más enrevesada, también tenemos una equivalencia en SQL.</p>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> <span class="token keyword keyword-DISTINCT">DISTINCT</span> <span class="token function">ROUND</span><span class="token punctuation">(</span>nota<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> notaMayor <span class="token keyword keyword-FROM">FROM</span> notas <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> notaMayor <span class="token keyword keyword-DESC">DESC</span> <span class="token keyword keyword-LIMIT">LIMIT</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div style="page-break-after:always;"></div>
<h4 id="groupby">GroupBy </h4>
<p>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave. Los elementos de cada grupo se proyectan utilizando una función determinada.</p>
<p>Existen diferentes sobrecargas posibles para usar la agrupación. Nosotros vamos a usar esta pues es la más '<em>intuitiva</em>'...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">&gt;</span></span> <span class="token function">GroupBy</span><span class="token punctuation">(</span>
                    <span class="token keyword keyword-this">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> source<span class="token punctuation">,</span>
                    <span class="token class-name">Func<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">,</span> TKey<span class="token punctuation">&gt;</span></span> keySelector<span class="token punctuation">,</span> 
                    <span class="token class-name">Func<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span><span class="token punctuation">,</span> TResult<span class="token punctuation">&gt;</span></span> resultSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Veamos como interpretarla:</p>
<ul>
<li><strong><code>keySelector</code></strong> será la función del selector de claves por las que agruparé la secuencia:
<ul>
<li><strong>Recibe</strong>: <code>TSource</code> que es el tipo de la secuencia a procesar.</li>
<li><strong>Devuelve</strong>:  <code>TKey</code> tipo la clave resultado del mapeo de TSource por que que voy a agrupar.</li>
</ul>
</li>
<li><strong><code>resultSelector</code></strong> será la función que proyecta los elemento de cada grupo con su clave:
<ul>
<li><strong>Recibe</strong>: <code>Tkey</code> con la clave por la que agrupo y la agrupación de los objetos <code>TSource</code> para esa clave.</li>
<li><strong>Devuelve</strong>: <code>TResult</code> con lo que quiero producir en la nueva secuencia resultado de la agrupación.</li>
</ul>
</li>
</ul>
<p>Bueno, hasta ahora ha sido una definición muy formal, pero vamos ha hacerlo con un ejemplo más sencillo para entenderlo. Supongamos nuestro array de notas anterior...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-double">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> notas <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">7.2</span><span class="token punctuation">,</span> <span class="token number">7.6</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">8.7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>Queremos agrupar el valor de las notas sin decimales y contabilizar el número de apariciones de las mismas.</p>
<p>Si estuviéramos en MySQL una posible consulta para resolverlo sería...</p>
<pre data-role="codeBlock" data-info="sql" class="language-sql sql"><code><span class="token keyword keyword-SELECT">SELECT</span> FLOOR<span class="token punctuation">(</span>nota<span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> notaRedondeada<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword keyword-AS">AS</span> veces 
<span class="token keyword keyword-FROM">FROM</span> notas <span class="token keyword keyword-GROUP">GROUP</span> <span class="token keyword keyword-BY">BY</span> notaRedondeada <span class="token keyword keyword-ORDER">ORDER</span> <span class="token keyword keyword-BY">BY</span> notaRedondeada<span class="token punctuation">;</span>
</code></pre><p>El equivalente utilizando la programación funcional y el <strong><code>GroupBy</code></strong> de C# sería ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-string">string</span></span> salida <span class="token operator">=</span> <span class="token string">"notaRedondeada veces\n"</span> <span class="token operator">+</span> 
notas<span class="token punctuation">.</span><span class="token function">GroupBy</span><span class="token punctuation">(</span>
        nota <span class="token operator">=&gt;</span> Math<span class="token punctuation">.</span><span class="token function">Floor</span><span class="token punctuation">(</span>nota<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span>nota<span class="token punctuation">,</span> elementosConMismaNota<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
                <span class="token keyword keyword-new">new</span>
                <span class="token punctuation">{</span>
                    NotaAgrupada <span class="token operator">=</span> nota<span class="token punctuation">,</span>
                    Veces <span class="token operator">=</span> elementosConMismaNota<span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">OrderBy</span><span class="token punctuation">(</span>datoAgrupado <span class="token operator">=&gt;</span> datoAgrupado<span class="token punctuation">.</span>NotaAgrupada<span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>
                <span class="token punctuation">(</span>texto<span class="token punctuation">,</span> datoAgrupado<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
                texto <span class="token operator">+=</span> <span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">datoAgrupado<span class="token punctuation">.</span>NotaAgrupada<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">14</span></span><span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">datoAgrupado<span class="token punctuation">.</span>Veces<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span></span><span class="token punctuation">}</span></span><span class="token string">\n"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>salida<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><blockquote>
<p>✋ <strong>Importante:</strong> Fíjate que aunque <strong><code>string salida = ...</code></strong> es una única expresión, hemos ido introduciendo saltos de línea e indentado el código para que sea legible y modificable nuestra expresión funcional. De otra manera el código sería prácticamente ilegible y difícil de modificar para un programador humano.</p>
</blockquote>
<p>Si comentamos el código anterior podríamos decir que:</p>
<ol>
<li>
<p>Nuestra función selectora (<code>Func&lt;TSource, TKey&gt; keySelector</code>) es:</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code>nota <span class="token operator">=&gt;</span> Math<span class="token punctuation">.</span><span class="token function">Floor</span><span class="token punctuation">(</span>nota<span class="token punctuation">)</span>
</code></pre><p>Siendo <code>TSource</code> los <strong>doubles</strong> de la secuencia de entrada con el identificador <strong><code>nota</code></strong>.<br>
Siendo <code>TKey</code> el <strong>double</strong> resultado de quedarnos con la parte entera de la nota <strong><code>Math.Floor(nota)</code></strong>.<br>
Todos los elementos de la lista de entrada que produzcan la misma clave <code>TKey</code>, estarán en el mismo grupo y por tanto se agruparán en una secuencia. En nuestro caso las claves generadas serán ...<br>
<code>[ 1, 3.4, 4.3, 4.6, 4.3, 7.2, 7.6, 5.6, 8.7 ]</code> → <code>[ 1, 3, 4, 5, 7, 8 ]</code></p>
</li>
<li>
<p>Nuestra función des proyección (<code>Func&lt;TKey, IEnumerable&lt;TSource&gt;, TResult&gt; resultSelector</code>) es:</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token punctuation">(</span>nota<span class="token punctuation">,</span> elementosConMismaNota<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span>
                <span class="token punctuation">{</span>
                    NotaAgrupada <span class="token operator">=</span> nota<span class="token punctuation">,</span>
                    Veces <span class="token operator">=</span> elementosConMismaNota<span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
</code></pre><p>Siendo <code>TKey</code> el <strong>double</strong> con la clave que recordemos es el resultado de aplicar <code>Floor</code> a la nota.<br>
Siendo <code>IEnumerable&lt;TSource&gt;</code> una nueva secuencia con los elementos de la secuencia original, esto es, las notas con decimales <strong>agrupadas a esa clave</strong>. Esto es, los elementos que generaron esa clave.<br>
Así pues, tendré las siguientes parejas de <strong>(clave, agrupación)</strong> en <code>(TKey, IEnumerable&lt;TSource&gt;)</code> en nuestro caso <strong><code>(nota, elementosConMismaNota)</code></strong></p>
<pre data-role="codeBlock" data-info="json" class="language-json json"><code>(<span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">1</span> <span class="token punctuation">]</span>)
(<span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">3.4</span> <span class="token punctuation">]</span>)
(<span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">4.6</span><span class="token punctuation">,</span> <span class="token number">4.3</span> <span class="token punctuation">]</span>)
(<span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">7.2</span><span class="token punctuation">,</span> <span class="token number">7.6</span> <span class="token punctuation">]</span>)
(<span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">5.6</span> <span class="token punctuation">]</span>)
(<span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token number">8.7</span> <span class="token punctuation">]</span>)
</code></pre><p>Siendo <code>TResult</code> la <strong>proyección</strong> resultante de gestionar los pares (clave, agrupación) anteriores. En nuestro caso objetos de la '<em>anónimos</em>' con dos propiedades <strong><code>NotaAgrupada</code></strong> y <strong><code>Veces</code></strong> que tendrá la cuenta de cada secuencia de notas agrupadas con la clave.<br>
Por tanto el resultado final será la secuencia de <code>TResult</code> siguiente...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token punctuation">[</span> 
  <span class="token punctuation">{</span> NotaAgrupada <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> Veces <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> NotaAgrupada <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> Veces <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span> NotaAgrupada <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> Veces <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> NotaAgrupada <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span> Veces <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span> NotaAgrupada <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> Veces <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> NotaAgrupada <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span> Veces <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span> 
<span class="token punctuation">]</span>
</code></pre></li>
<li>
<p>La función</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token punctuation">.</span><span class="token function">OrderBy</span><span class="token punctuation">(</span>datoAgrupado <span class="token operator">=&gt;</span> datoAgrupado<span class="token punctuation">.</span>NotaAgrupada<span class="token punctuation">)</span>
</code></pre><p>aplicada a la secuencia anterior de objetos anónimos producirá la misma secuencia pero ordenada por la propiedad <strong><code>NotaAgrupada</code></strong>.</p>
</li>
<li>
<p>La función</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>texto<span class="token punctuation">,</span> datoAgrupado<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
          texto <span class="token operator">+=</span> <span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">datoAgrupado<span class="token punctuation">.</span>NotaAgrupada<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">14</span></span><span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">datoAgrupado<span class="token punctuation">.</span>Veces<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span></span><span class="token punctuation">}</span></span><span class="token string">\n"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Genera una cadena con los pares nota sin decimales y veces que aparece alineados y separados por un salto de línea.</p>
</li>
</ol>
<div style="page-break-after:always;"></div>
<p><strong>Ejemplo:</strong> Veamos un ejemplo algo más elaborado usando una secuencia con un tipo algo más complejo que un double. Para ello, supongamos la siguiente clase inmutable que define los datos de un empleado de una determinada empresa...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-public">public</span> <span class="token keyword keyword-enum">enum</span> <span class="token class-name">Ciudad</span> <span class="token punctuation">{</span> Elche<span class="token punctuation">,</span> Alicante <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-public">public</span> <span class="token keyword keyword-record">record</span> <span class="token class-name">Empleado</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> Nombre<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword keyword-int">int</span></span> Edad<span class="token punctuation">,</span> <span class="token class-name">Ciudad</span> Ciudad<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-public">public</span> <span class="token keyword keyword-override">override</span> <span class="token return-type class-name"><span class="token keyword keyword-string">string</span></span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">Nombre<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">9</span></span><span class="token punctuation">}</span></span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">Edad<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span></span><span class="token punctuation">}</span></span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">Ciudad</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Ahora definimos una clase de utilidad que me devuelva una secuencia de empleados de forma <em>'perezosa'</em>...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">Empleados</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span></span> DepartamentoDeVentas
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-get">get</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-yield">yield</span> <span class="token keyword keyword-return">return</span>
            <span class="token keyword keyword-new">new</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">Nombre</span><span class="token punctuation">:</span> <span class="token string">"Xusa"</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Edad</span><span class="token punctuation">:</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Ciudad</span><span class="token punctuation">:</span> Ciudad<span class="token punctuation">.</span>Alicante<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-yield">yield</span> <span class="token keyword keyword-return">return</span>
            <span class="token keyword keyword-new">new</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">Nombre</span><span class="token punctuation">:</span> <span class="token string">"Simon"</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Edad</span><span class="token punctuation">:</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Ciudad</span><span class="token punctuation">:</span> Ciudad<span class="token punctuation">.</span>Alicante<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-yield">yield</span> <span class="token keyword keyword-return">return</span>
            <span class="token keyword keyword-new">new</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">Nombre</span><span class="token punctuation">:</span> <span class="token string">"Carmen"</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Edad</span><span class="token punctuation">:</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Ciudad</span><span class="token punctuation">:</span> Ciudad<span class="token punctuation">.</span>Elche<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-yield">yield</span> <span class="token keyword keyword-return">return</span>
            <span class="token keyword keyword-new">new</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">Nombre</span><span class="token punctuation">:</span> <span class="token string">"Juanjo"</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Edad</span><span class="token punctuation">:</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Ciudad</span><span class="token punctuation">:</span> Ciudad<span class="token punctuation">.</span>Elche<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-yield">yield</span> <span class="token keyword keyword-return">return</span>
            <span class="token keyword keyword-new">new</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">Nombre</span><span class="token punctuation">:</span> <span class="token string">"Emy"</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Edad</span><span class="token punctuation">:</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">Ciudad</span><span class="token punctuation">:</span> Ciudad<span class="token punctuation">.</span>Elche<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Queremos obtener un array con los nombres de los empleados mayores de 40 años sin repeticiones y ordenados por nombre.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> nombres <span class="token operator">=</span> Empleados<span class="token punctuation">.</span>DepartamentoDeVentas
                            <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Edad <span class="token operator">&gt;</span> <span class="token number">40</span><span class="token punctuation">)</span>  <span class="token comment">// Filtramos por edad.</span>
                            <span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Nombre<span class="token punctuation">)</span>    <span class="token comment">// Proyectamos la propiedad Nombre </span>
                                                      <span class="token comment">// a una nueva secuencia.</span>
                            <span class="token punctuation">.</span><span class="token function">OrderBy</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> n<span class="token punctuation">)</span>          <span class="token comment">// Ordenamos por nombre.</span>
                            <span class="token punctuation">.</span><span class="token function">Distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token comment">// Eliminamos repetidos.</span>
                            <span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// Pasamos la secuencia a array.</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">,</span> nombres<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Supongamos que ahora queremos obtener los empleados mayores de 40 años agrupados por ciudad usando <strong><code>GroupBy</code></strong>.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-var">var</span></span> empleadosXCiudad <span class="token operator">=</span> Empleados<span class="token punctuation">.</span>DepartamentoDeVentas
                                <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Edad <span class="token operator">&gt;</span> <span class="token number">40</span><span class="token punctuation">)</span>
                                <span class="token punctuation">.</span><span class="token function">GroupBy</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Ciudad<span class="token punctuation">,</span> 
                                         <span class="token punctuation">(</span>c<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token punctuation">{</span>Ciudad <span class="token operator">=</span> c<span class="token punctuation">,</span> Empleados <span class="token operator">=</span> g<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>El tipo de <strong><code>empleadosXCiudad</code></strong> debe ser implícito (<strong><code>var</code></strong>) pues la secuencia que estamos creando es de un tipo implícito (<strong><code>new {Ciudad = c, Empleados = g}</code></strong>) que estamos definiendo en la función de proyección del <strong><code>GroupBy</code></strong>.</p>
<p>Ahora queremos mostrar los datos de la siguiente manera con los empleados ordenados por edad ....</p>
<pre data-role="codeBlock" data-info="txt" class="language-txt txt"><code>Alicante:
        Xusa     45 Alicante
        Juanjo   51 Alicante
Elche:
        Juanjo   45 Elche
        Emy      52 Elche
</code></pre><p>Aunque la secuencia sea de un tipo implícito podremos componer una cadena con la salida deseada.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name">StringBuilder</span> salida <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-foreach">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-var">var</span></span> eXc <span class="token keyword keyword-in">in</span> empleadosXCiudad<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    salida<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">eXc<span class="token punctuation">.</span>Ciudad</span><span class="token punctuation">}</span></span><span class="token string">:\n"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-foreach">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Empleado</span> e <span class="token keyword keyword-in">in</span> eXc<span class="token punctuation">.</span>Empleados<span class="token punctuation">.</span><span class="token function">OrderBy</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Edad<span class="token punctuation">)</span><span class="token punctuation">)</span>
        salida<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"\t</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">e</span><span class="token punctuation">}</span></span><span class="token string">\n"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>salida<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><blockquote>
<p>📌 <strong>Nota</strong>: Al ser la secuencia de un tipo implícito o anónimo, solo podremos recorrer la secuiencia en el mismo ámbito de uso de tipo. Si intentáramos encapsular el la obtención de la secuencia en una función, no podríamos devolverla como tal, sino que deberíamos encapsularla en un tipo de datos o clase que la contuviera.</p>
<p>Lo mismo sucedería si quisieramos encapsular el código que muestra los datos en pantalla. No sabríamos de que tipo asignarle a la secuencia que pasaríamos como parámetro.</p>
</blockquote>
<div style="page-break-after:always;"></div>
<h5 id="resultado-del-groupby-en-un-nuevo-tipo-de-datos">Resultado del GroupBy en un nuevo tipo de datos </h5>
<p>Supongamos que hubiéramos querido encapsular la obtención de <strong><code>empleadosXCiudad</code></strong> en una función y hacer el mismo proceso modularizado. Puesto que la secuencia es de un tipo anónimo, nos hubiéramos visto obligados ha definir una nueva clase con una propiedad <strong><code>Ciudad</code></strong> del tipo enumerado y otra <strong><code>Empleados</code></strong> como secuencia de objetos empleados por ejemplo.</p>
<blockquote>
<p>✋ <strong>Importante</strong>: Al este tipo de datos o clase que definimos para obtener el resultado de una consulta y que únicamente tienen como misión transportar los datos de la consulta, se les denomina <strong><code>DTO</code></strong> <a href="https://es.wikipedia.org/wiki/Objeto_de_transferencia_de_datos">Data Transfer Object</a> y deben ser inmutables y tener la mínima funcionalidad posible. Por eso el modificador <strong><code>record </code></strong> es el más adecuado para definirlos.</p>
</blockquote>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// Definimos el tipo.</span>
<span class="token keyword keyword-record">record</span> <span class="token class-name">EmpleadosPorCiudadDto</span><span class="token punctuation">(</span><span class="token class-name">Ciudad</span> Ciudad<span class="token punctuation">,</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span></span> Empleados<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Podemos definir un valor de retorno con un tipo concreto para la secuencia.</span>
<span class="token comment">// En este caso hemos quitado la restricción de mayores de 40 por simplificar.</span>
<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>EmpleadosPorCiudadDto<span class="token punctuation">&gt;</span></span> <span class="token function">EmpleadosVentasPorCiudad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
Empleados<span class="token punctuation">.</span>DepartamentoDeVentas
            <span class="token punctuation">.</span><span class="token function">GroupBy</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Ciudad<span class="token punctuation">,</span>
                     <span class="token punctuation">(</span>c<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">EmpleadosPorCiudadDto</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">Ciudad</span><span class="token punctuation">:</span> c<span class="token punctuation">,</span> <span class="token named-parameter punctuation">Empleados</span><span class="token punctuation">:</span> g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Al tener un tipo concreto, también podemos modularizar la composición de la salida.</span>
<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-string">string</span></span> <span class="token function">ATexto</span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>EmpleadosPorCiudadDto<span class="token punctuation">&gt;</span></span> empleadosXCiudad<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">StringBuilder</span> salida <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-foreach">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-var">var</span></span> eXc <span class="token keyword keyword-in">in</span> empleadosXCiudad<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        salida<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">eXc<span class="token punctuation">.</span>Ciudad</span><span class="token punctuation">}</span></span><span class="token string">:\n"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-foreach">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Empleado</span> e <span class="token keyword keyword-in">in</span> eXc<span class="token punctuation">.</span>Empleados<span class="token punctuation">.</span><span class="token function">OrderBy</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Edad<span class="token punctuation">)</span><span class="token punctuation">)</span>
            salida<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"\t</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">e</span><span class="token punctuation">}</span></span><span class="token string">\n"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> salida<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Posteriormente hacer la llamada a las funciones.</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">ATexto</span><span class="token punctuation">(</span><span class="token function">EmpleadosVentasPorCiudad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     
</code></pre><p>En este caso no hemos filtrado por edad como hacíamos en el caso inicial. Pero si quisieramos hacerlo a posteiori, podríamos hacerlo de la siguiente manera...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-var">var</span></span> empleadosXCiudad <span class="token operator">=</span> <span class="token function">EmpleadosVentasPorCiudad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Mapeamos al mismo DTO pero filtrando la propiedad Empleados por edad.</span>
<span class="token comment">// Fíjate que al ser inmutable EmpleadosPorCiudadDto, </span>
<span class="token comment">// para no tener que crear un nuevo objeto copiando propiedad a propiedad.</span>
<span class="token comment">// Usamos el operador with para crear una nueva instancia </span>
<span class="token comment">// con la propiedad Empleados filtrada.</span>
<span class="token class-name"><span class="token keyword keyword-var">var</span></span> empleadosXCiudadMas40 <span class="token operator">=</span> empleadosXCiudad<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>
    eXc <span class="token operator">=&gt;</span> eXc <span class="token keyword keyword-with">with</span> <span class="token punctuation">{</span> Empleados <span class="token operator">=</span> eXc<span class="token punctuation">.</span>Empleados<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Edad <span class="token operator">&gt;</span> <span class="token number">40</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">ATexto</span><span class="token punctuation">(</span>empleadosXCiudadMas40<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     
</code></pre><h5 id="resultado-del-grupby-en-un-diccionario">Resultado del GrupBy en un diccionario </h5>
<p>Pero, ¿Habría la posibilidad de retornar la agrupación por clave sin tener que definir el tipo <strong><code>EmpleadosPorCiudadDto</code></strong>?. Podríamos utilizar la posibilidad de transformar cualquier secuencia a las colecciones definidas en el lenguaje.</p>
<p>Por ejemplo vamos a definir la misma función <strong><code>EmpleadosVentasPorCiudad</code></strong> pero en lugar de retornar <strong><code>IEnumerable&lt;EmpleadosPorCiudadDto&gt;</code></strong> ahora retornará <strong><code>Dictionary&lt;Ciudad, List&lt;Empleado&gt;&gt;</code></strong> y así no tendríamos que definir el tipo.</p>
<p>Es fácil e inmediato transformar una secuencia a un array o una lista.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span></span> secuencia <span class="token operator">=</span> <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">;</span>

<span class="token class-name">Empleado<span class="token punctuation">[</span><span class="token punctuation">]</span></span> arrayEmpleados <span class="token operator">=</span> secuencia<span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span></span> listaEmpleados <span class="token operator">=</span> secuencia<span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Pero si queremos crear un diccionario, deberíamos poder indicarle de donde sacamos las claves y los valores asociados infiriendo en ambos casos los tipos parametrizados en el diccionario. Una vez más nos ayudarán la funciones de orden superior (HOF) para hacerlo en este caso podemos usar la siguiente definición de <strong><code>ToDictionary</code></strong>...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">Dictionary<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TElement<span class="token punctuation">&gt;</span></span> 
<span class="token generic-method"><span class="token function">ToDictionary</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">,</span> TKey<span class="token punctuation">,</span> TElement<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>
                <span class="token keyword keyword-this">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> source<span class="token punctuation">,</span>
                <span class="token class-name">Func<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">,</span> TKey<span class="token punctuation">&gt;</span></span> keySelector<span class="token punctuation">,</span> 
                <span class="token class-name">Func<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">,</span> TElement<span class="token punctuation">&gt;</span></span> elementSelector<span class="token punctuation">)</span> <span class="token keyword keyword-where">where</span> <span class="token class-name">TKey</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword keyword-notnull">notnull</span></span><span class="token punctuation">;</span>
</code></pre><p>Donde <strong><code>Func&lt;TSource, TKey&gt; keySelector</code></strong> nos ayudará a decidir que propiedad será la clave del tipo anónimo de entrada <strong><code>TSource</code></strong> y <strong><code>Func&lt;TSource, TElement&gt; elementSelector)</code></strong> hará el proceso análogo para el valor asociado a la clave. Quedando la función anterior.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-private">private</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">Dictionary<span class="token punctuation">&lt;</span>Ciudad<span class="token punctuation">,</span> List<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">EmpleadosVentasPorCiudad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
Empleados<span class="token punctuation">.</span>DepartamentoDeVentas
          <span class="token punctuation">.</span><span class="token function">GroupBy</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Ciudad<span class="token punctuation">,</span>
                <span class="token punctuation">(</span>c<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token punctuation">{</span> Ciudad <span class="token operator">=</span> c<span class="token punctuation">,</span> Empleados <span class="token operator">=</span> g <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">ToDictionary</span><span class="token punctuation">(</span>eXc <span class="token operator">=&gt;</span> eXc<span class="token punctuation">.</span>Ciudad<span class="token punctuation">,</span> eXc <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>eXc<span class="token punctuation">.</span>Empleados<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Por último, queremos poder filtrar los empleados de ventas que queremos agrupar por ciudad por cualquier predicado. Una vez más podremos aplicar programación funcional y pasar la estrategia de filtrado como parámetro.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// En este caso no necesitamos un tipo concreto, podemos usar un diccionario.</span>
<span class="token comment">// y mejoramos la funcionalidad anterior para que admita un filtro mediante una HOF.</span>
<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">Dictionary<span class="token punctuation">&lt;</span>Ciudad<span class="token punctuation">,</span> List<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> 
<span class="token function">EmpleadosVentasPorCiudad</span><span class="token punctuation">(</span><span class="token class-name">Func<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">,</span> <span class="token keyword keyword-bool">bool</span><span class="token punctuation">&gt;</span></span> filtroEmpleado<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
Empleados<span class="token punctuation">.</span>DepartamentoDeVentas
          <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>filtroEmpleado<span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">GroupBy</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Ciudad<span class="token punctuation">,</span>
                <span class="token punctuation">(</span>c<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token punctuation">{</span> Ciudad <span class="token operator">=</span> c<span class="token punctuation">,</span> Empleados <span class="token operator">=</span> g <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">ToDictionary</span><span class="token punctuation">(</span>eXc <span class="token operator">=&gt;</span> eXc<span class="token punctuation">.</span>Ciudad<span class="token punctuation">,</span> eXc <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>eXc<span class="token punctuation">.</span>Empleados<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-private">private</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-string">string</span></span> <span class="token function">ATexto</span><span class="token punctuation">(</span><span class="token class-name">Dictionary<span class="token punctuation">&lt;</span>Ciudad<span class="token punctuation">,</span> List<span class="token punctuation">&lt;</span>Empleado<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> empleadosXCiudad<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">StringBuilder</span> salida <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-foreach">foreach</span> <span class="token punctuation">(</span><span class="token keyword keyword-var">var</span> <span class="token punctuation">(</span>cuidad<span class="token punctuation">,</span> empleados<span class="token punctuation">)</span> <span class="token keyword keyword-in">in</span> empleadosXCiudad<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        salida<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">cuidad</span><span class="token punctuation">}</span></span><span class="token string">:\n"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-foreach">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Empleado</span> e <span class="token keyword keyword-in">in</span> empleados<span class="token punctuation">.</span><span class="token function">OrderBy</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Edad<span class="token punctuation">)</span><span class="token punctuation">)</span>
            salida<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"\t</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">e</span><span class="token punctuation">}</span></span><span class="token string">\n"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> salida<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-var">var</span> empleadosVentasPorCiudadDeMasDe40Años <span class="token operator">=</span> 
    <span class="token function">EmpleadosVentasPorCiudad</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> e<span class="token punctuation">.</span>Edad <span class="token operator">&gt;</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">ATexto</span><span class="token punctuation">(</span>empleadosVentasPorCiudadDeMasDe40Años<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div style="page-break-after:always;"></div>
<h4 id="zip">Zip </h4>
<p>Se trata de una <a href="https://en.wikipedia.org/wiki/Zipping_(computer_science)">operación típica en los lenguajes funcionales</a> al permitirnos manejar el concepto de tupla y que por tanto podemos <a href="https://docs.microsoft.com/es-es/dotnet/api/system.linq.enumerable.zip">encontrar también en C#</a> ya que también nos los permite.</p>
<p>Básicamente realiza una correspondencia unívoca entre los elementos de <strong>dos</strong> o más secuencias iterables, produciendo una <strong>nueva secuencia de tuplas</strong> resultado de dicha correspondencia. Obviamente, su nombre viene de la analogía de cerrar una cremallera.</p>
<p>Supongamos <strong>Sec[A]</strong> = [🐮, 🐟, 🍠, 🐔, 🌽] y <strong>Sec[B]</strong> = [🍔, 🍥, 🍟, 🍗, 🍿]</p>
<p><strong>zip(Sec[A], Sec[B])</strong> = [ <strong>(</strong>🐮, 🍔<strong>)</strong>, <strong>(</strong>🐟, 🍥<strong>)</strong> , <strong>(</strong>🍠, 🍟<strong>)</strong>, <strong>(</strong>🐔, 🍗<strong>)</strong>, <strong>(</strong>🌽, 🍿<strong>)</strong> ]</p>
<p><strong>Ejemplo:</strong> Supongamos que tenemos dos arrays. Uno con nombres de país y otro su población en millones de habitantes. Queremos mostrar una correlación entre ambos arrays por pantalla en forma de texto. Una aproximación funcional a la solución desde C# podría ser...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> paises <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"China"</span><span class="token punctuation">,</span> <span class="token string">"India"</span><span class="token punctuation">,</span> <span class="token string">"Estados Unidos"</span><span class="token punctuation">,</span> <span class="token string">"Indonesia"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> poblaciones <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1391</span><span class="token punctuation">,</span> <span class="token number">1364</span><span class="token punctuation">,</span> <span class="token number">327</span><span class="token punctuation">,</span> <span class="token number">264</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name"><span class="token keyword keyword-string">string</span></span> salida  <span class="token operator">=</span> <span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">,</span>
                 paises<span class="token punctuation">.</span><span class="token function">Zip</span><span class="token punctuation">(</span>poblaciones<span class="token punctuation">)</span>
                       <span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>t <span class="token operator">=&gt;</span> <span class="token interpolation-string"><span class="token string">$"Población </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">t<span class="token punctuation">.</span>First</span><span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">t<span class="token punctuation">.</span>Second</span><span class="token punctuation">}</span></span><span class="token string"> millones."</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>salida<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Mostrará por pantalla...</p>
<pre data-role="codeBlock" data-info="txt" class="language-txt txt"><code>Población China 1391 millones.        
Población India 1364 millones.        
Población Estados Unidos 327 millones.
Población Indonesia 264 millones.
</code></pre><p>Fíjate que la función <strong><code>paises.Zip(poblaciones)</code></strong> me genera una secuencia de tuplas del tipo <strong><code>(string , int)</code></strong> → <code>[("China", 1391), (India, 1364)], ... ]</code> y posteriormente en la función de mapeo genera una nueva secuencia de cadenas componiendo los elementos de la tupla <strong>t</strong>.</p>
<div style="page-break-after:always;"></div>
<blockquote>
<p>📌 <strong>Nota:</strong> La operación inversa <strong>Unzip</strong> no está definida en el lenguaje porque se puede realizar fácilmente con un mapeo...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token punctuation">(</span><span class="token keyword keyword-string">string</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> datos <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">,</span> <span class="token number">1391</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"India"</span><span class="token punctuation">,</span> <span class="token number">1364</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Estados Unidos"</span><span class="token punctuation">,</span> <span class="token number">327</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Indonesia"</span><span class="token punctuation">,</span> <span class="token number">264</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> paises <span class="token operator">=</span> datos<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>t <span class="token operator">=&gt;</span> t<span class="token punctuation">.</span>Item1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> poblacion <span class="token operator">=</span> datos<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>t <span class="token operator">=&gt;</span> t<span class="token punctuation">.</span>Item2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></blockquote>
<p>Si quisieramos hacer un <strong><code>Zip</code></strong> de tres secuencias o más secuencias, podríamos aplicar la función varias veces. En el siguiente ejemplo vamos acombinar los varires de tres vectores en una tupla de tres elementos correpondientes a coordenas en el espacio.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> v1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> v2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> v3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-int">int</span></span> x<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword keyword-int">int</span></span> y<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword keyword-int">int</span></span> z<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> agrupacion <span class="token operator">=</span> v1
    <span class="token comment">// Combinamos v1 con v2</span>
    <span class="token punctuation">.</span><span class="token function">Zip</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">)</span> 
    <span class="token comment">// Combinamos las tuplas resultantes con v3</span>
    <span class="token punctuation">.</span><span class="token function">Zip</span><span class="token punctuation">(</span>v3<span class="token punctuation">,</span> <span class="token punctuation">(</span>t12<span class="token punctuation">,</span> d3<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>t12<span class="token punctuation">.</span>d1<span class="token punctuation">,</span> t12<span class="token punctuation">.</span>d2<span class="token punctuation">,</span> d3<span class="token punctuation">)</span><span class="token punctuation">)</span>  
    <span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-foreach">foreach</span> <span class="token punctuation">(</span><span class="token keyword keyword-var">var</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token keyword keyword-in">in</span> agrupacion<span class="token punctuation">)</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"(</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">x</span><span class="token punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">y</span><span class="token punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">z</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div style="page-break-after:always;"></div>
<h4 id="flatmap-o-aplanado">FlatMap o Aplanado </h4>
<p>La operación de aplanado es otra de las funciones típicas de la programación funcional que vamos a encontrar en todos los lenguajes funcionales y otros como JavaScript, Java o C#. A este tipo de HOF se le conoce como <strong><a href="https://es.wikipedia.org/wiki/M%C3%B3nada_(programaci%C3%B3n_funcional)">mónada</a></strong> porque cumple ciertas operaciones matemáticas en la que no vamos a entrar por estar fuera del tema, pero que si has visto la <strong><a href="https://es.wikipedia.org/wiki/M%C3%B3nada_(programaci%C3%B3n_funcional)#Definici%C3%B3n_Formal">definición formal</a></strong> del enlace anterior seguramente no te hayas enterado de nada si no tienes una profunda base matemática del la teoría de categorías.</p>
<p>Pero siguiendo la analogía que hemos usado en el tema, podemos definirla como:<br>
<strong>flatMap = Sec[A] x (A → Sec[B]) → Sec[B]</strong></p>
<p>Donde dada una <strong>Sec[A]</strong> le vamos a aplicar una función <strong>A → Sec[B]</strong> donde para cada elemento de <strong>A</strong> produce una secuencia de <strong>B</strong> <strong>Sec[B]</strong> y el resultado será una <strong>Sec[B]</strong> resultado de <strong>unir</strong> todas los <strong>Sec[B]</strong> producidos por cada <strong>A</strong>.</p>
<p><strong>¿Sigue sin quedar claro?</strong>. No pasa nada, vamos a verlo a través de un ejemplo sencillo, pero esta vez en lugar de usar iconos, vamos a usar enteros y programa sencillo en C#.</p>
<p>En primer lugar comentaremos que la función equivalente en C# que más se aproxima a esta definición básica de <strong>FlatMap</strong> es <strong><a href="https://docs.microsoft.com/es-es/dotnet/api/system.linq.enumerable.selectmany#system-linq-enumerable-selectmany-2(system-collections-generic-ienumerable((-0))-system-func((-0-system-collections-generic-ienumerable((-1)))))">SelectMany</a></strong> y en concreto la sobrecarga siguiente:</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>B<span class="token punctuation">&gt;</span></span> <span class="token generic-method"><span class="token function">SelectMany</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>A<span class="token punctuation">,</span> B<span class="token punctuation">&gt;</span></span></span> <span class="token punctuation">(</span>
                            <span class="token keyword keyword-this">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> source<span class="token punctuation">,</span>
                            <span class="token class-name">Func<span class="token punctuation">&lt;</span>A<span class="token punctuation">,</span> IEnumerable<span class="token punctuation">&lt;</span>B<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Supongamos la siguiente de representación donde tenemos el típico array de arrays o tabla dentada. En el fondo, podemos considerarlo como una secuencia de secuencias (sub-secuencias) de enteros:</p>
<p></p><p align="center" style="zoom:0.7" class="dot"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<!-- Generated by graphviz version 9.0.0 (20230911.1827)
 -->
<!-- Title: G Pages: 1 -->
<svg width="685pt" height="235pt" viewBox="0.00 0.00 684.86 235.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 231)">
<title>G</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-231 680.86,-231 680.86,4 -4,4"></polygon>
<!-- ot1 -->
<g id="node1" class="node">
<title>ot1</title>
<polygon fill="none" stroke="black" points="42,-188.6 42,-222.6 76,-222.6 76,-188.6 42,-188.6"></polygon>
<polygon fill="none" stroke="black" points="76,-188.6 76,-222.6 110,-222.6 110,-188.6 76,-188.6"></polygon>
<polygon fill="none" stroke="black" points="110,-188.6 110,-222.6 144,-222.6 144,-188.6 110,-188.6"></polygon>
<polygon fill="none" stroke="black" points="144,-188.6 144,-222.6 178,-222.6 178,-188.6 144,-188.6"></polygon>
</g>
<!-- ot11 -->
<g id="node2" class="node">
<title>ot11</title>
<polygon fill="none" stroke="black" points="10.21,-73.6 10.21,-108.4 43.79,-108.4 43.79,-73.6 10.21,-73.6"></polygon>
<text text-anchor="start" x="19.21" y="-86.8" font-family="Arial" font-size="14.00">11</text>
<polygon fill="none" stroke="black" points="10.21,-38.8 10.21,-73.6 43.79,-73.6 43.79,-38.8 10.21,-38.8"></polygon>
<text text-anchor="start" x="19.21" y="-52" font-family="Arial" font-size="14.00">22</text>
</g>
<!-- ot1&#45;&gt;ot11 -->
<g id="edge1" class="edge">
<title>ot1:c-&gt;ot11:n</title>
<path fill="none" stroke="black" d="M53.43,-188.75C46.91,-170.21 36.3,-140.05 30.71,-124.16"></path>
<polygon fill="black" stroke="black" points="27.4,-114.75 34.97,-122.69 28.66,-118.32 30.72,-124.18 30.72,-124.18 30.72,-124.18 28.66,-118.32 26.48,-125.68 27.4,-114.75"></polygon>
</g>
<!-- ot12 -->
<g id="node3" class="node">
<title>ot12</title>
<polygon fill="none" stroke="black" points="65.21,-91 65.21,-125.8 98.79,-125.8 98.79,-91 65.21,-91"></polygon>
<text text-anchor="start" x="74.21" y="-104.2" font-family="Arial" font-size="14.00">34</text>
<polygon fill="none" stroke="black" points="65.21,-56.2 65.21,-91 98.79,-91 98.79,-56.2 65.21,-56.2"></polygon>
<text text-anchor="start" x="74.21" y="-69.4" font-family="Arial" font-size="14.00">35</text>
<polygon fill="none" stroke="black" points="65.21,-21.4 65.21,-56.2 98.79,-56.2 98.79,-21.4 65.21,-21.4"></polygon>
<text text-anchor="start" x="74.21" y="-34.6" font-family="Arial" font-size="14.00">29</text>
</g>
<!-- ot1&#45;&gt;ot12 -->
<g id="edge2" class="edge">
<title>ot1:c-&gt;ot12:n</title>
<path fill="none" stroke="black" d="M90.67,-188.91C88.55,-174.65 85.48,-154 83.62,-141.48"></path>
<polygon fill="black" stroke="black" points="82.18,-131.81 88.1,-141.03 82.74,-135.55 83.65,-141.7 83.65,-141.7 83.65,-141.7 82.74,-135.55 79.2,-142.36 82.18,-131.81"></polygon>
</g>
<!-- ot13 -->
<g id="node4" class="node">
<title>ot13</title>
<polygon fill="none" stroke="black" points="120.21,-56.2 120.21,-91 153.79,-91 153.79,-56.2 120.21,-56.2"></polygon>
<text text-anchor="start" x="129.21" y="-69.4" font-family="Arial" font-size="14.00">10</text>
</g>
<!-- ot1&#45;&gt;ot13 -->
<g id="edge3" class="edge">
<title>ot1:c-&gt;ot13:n</title>
<path fill="none" stroke="black" d="M128.43,-188.98C130.48,-166.61 134.21,-126.01 135.99,-106.56"></path>
<polygon fill="black" stroke="black" points="136.89,-96.81 140.46,-107.18 136.54,-100.58 135.97,-106.77 135.97,-106.77 135.97,-106.77 136.54,-100.58 131.49,-106.36 136.89,-96.81"></polygon>
</g>
<!-- ot14 -->
<g id="node5" class="node">
<title>ot14</title>
<polygon fill="none" stroke="black" points="175.21,-108.4 175.21,-143.2 208.79,-143.2 208.79,-108.4 175.21,-108.4"></polygon>
<text text-anchor="start" x="184.21" y="-121.6" font-family="Arial" font-size="14.00">17</text>
<polygon fill="none" stroke="black" points="175.21,-73.6 175.21,-108.4 208.79,-108.4 208.79,-73.6 175.21,-73.6"></polygon>
<text text-anchor="start" x="184.21" y="-86.8" font-family="Arial" font-size="14.00">14</text>
<polygon fill="none" stroke="black" points="175.21,-38.8 175.21,-73.6 208.79,-73.6 208.79,-38.8 175.21,-38.8"></polygon>
<text text-anchor="start" x="184.21" y="-52" font-family="Arial" font-size="14.00">30</text>
<polygon fill="none" stroke="black" points="175.21,-4 175.21,-38.8 208.79,-38.8 208.79,-4 175.21,-4"></polygon>
<text text-anchor="start" x="184.21" y="-17.2" font-family="Arial" font-size="14.00">31</text>
</g>
<!-- ot1&#45;&gt;ot14 -->
<g id="edge4" class="edge">
<title>ot1:c-&gt;ot14:n</title>
<path fill="none" stroke="black" d="M169.64,-188.61C175.15,-178.39 182.13,-165.48 186.81,-156.82"></path>
<polygon fill="black" stroke="black" points="191.42,-148.27 190.63,-159.21 189.62,-151.6 186.67,-157.07 186.67,-157.07 186.67,-157.07 189.62,-151.6 182.71,-154.93 191.42,-148.27"></polygon>
</g>
<!-- otFlat -->
<g id="node6" class="node">
<title>otFlat</title>
<polygon fill="none" stroke="black" points="333.14,-188.2 333.14,-223 366.71,-223 366.71,-188.2 333.14,-188.2"></polygon>
<text text-anchor="start" x="342.14" y="-201.4" font-family="Arial" font-size="14.00">11</text>
<polygon fill="none" stroke="black" points="366.71,-188.2 366.71,-223 400.28,-223 400.28,-188.2 366.71,-188.2"></polygon>
<text text-anchor="start" x="375.71" y="-201.4" font-family="Arial" font-size="14.00">22</text>
<polygon fill="none" stroke="black" points="400.28,-188.2 400.28,-223 433.86,-223 433.86,-188.2 400.28,-188.2"></polygon>
<text text-anchor="start" x="409.28" y="-201.4" font-family="Arial" font-size="14.00">34</text>
<polygon fill="none" stroke="black" points="433.86,-188.2 433.86,-223 467.43,-223 467.43,-188.2 433.86,-188.2"></polygon>
<text text-anchor="start" x="442.86" y="-201.4" font-family="Arial" font-size="14.00">35</text>
<polygon fill="none" stroke="black" points="467.43,-188.2 467.43,-223 501,-223 501,-188.2 467.43,-188.2"></polygon>
<text text-anchor="start" x="476.43" y="-201.4" font-family="Arial" font-size="14.00">29</text>
<polygon fill="none" stroke="black" points="501,-188.2 501,-223 534.57,-223 534.57,-188.2 501,-188.2"></polygon>
<text text-anchor="start" x="510" y="-201.4" font-family="Arial" font-size="14.00">10</text>
<polygon fill="none" stroke="black" points="534.57,-188.2 534.57,-223 568.14,-223 568.14,-188.2 534.57,-188.2"></polygon>
<text text-anchor="start" x="543.57" y="-201.4" font-family="Arial" font-size="14.00">17</text>
<polygon fill="none" stroke="black" points="568.14,-188.2 568.14,-223 601.72,-223 601.72,-188.2 568.14,-188.2"></polygon>
<text text-anchor="start" x="577.14" y="-201.4" font-family="Arial" font-size="14.00">14</text>
<polygon fill="none" stroke="black" points="601.72,-188.2 601.72,-223 635.29,-223 635.29,-188.2 601.72,-188.2"></polygon>
<text text-anchor="start" x="610.72" y="-201.4" font-family="Arial" font-size="14.00">30</text>
<polygon fill="none" stroke="black" points="635.29,-188.2 635.29,-223 668.86,-223 668.86,-188.2 635.29,-188.2"></polygon>
<text text-anchor="start" x="644.29" y="-201.4" font-family="Arial" font-size="14.00">31</text>
</g>
<!-- ot1&#45;&gt;otFlat -->
<g id="edge5" class="edge">
<title>ot1-&gt;otFlat</title>
<path fill="none" stroke="blue" d="M185.85,-205.6C222.6,-205.6 268.52,-205.6 313.83,-205.6"></path>
<polygon fill="none" stroke="blue" points="313.82,-209.1 323.82,-205.6 313.82,-202.1 313.82,-209.1"></polygon>
<text text-anchor="middle" x="255.57" y="-212.8" font-family="Arial" font-size="14.00" fill="blue">Flat o Aplanado</text>
</g>
</g>
</svg>
</p><p></p>
<p>Si te fijas en el diagrama podemos ver que la operación de flat consiste en generar una nueva secuencia con datos de las sub-secuencias de entrada. El efecto es como si estuviéramos '<em>aplanando</em>' la tabla dentada.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> jagged <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span><span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// SelectMany = int[][] → (int[] → int[]) → int[]</span>
<span class="token class-name"><span class="token keyword keyword-int">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> flat <span class="token operator">=</span> jagged<span class="token punctuation">.</span><span class="token function">SelectMany</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">,</span> flat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Mostrará por pantalla: 11, 22, 34, 25, 29, 10, 17, 14, 30, 31</span>
</code></pre><p>Vemos un ejemplo más ilustrativo de este tipo de operación con tipos más elaborados.</p>
<p>Supongamos que la siguiente típica relación de cardinalidad uno a varios entre <strong><code>Autor</code></strong> y <strong><code>Libro</code></strong>. Donde suponemos que un autor ha escrito uno o varios libros y que modelizaremos de la siguiente manera...</p>
<p></p><p align="center" style="zoom:1" class="puml"><!--?xml version="1.0" encoding="us-ascii" standalone="no"?--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentstyletype="text/css" height="106px" preserveAspectRatio="none" style="width:456px;height:106px;background:#FFFFFF;" version="1.1" viewBox="0 0 456 106" width="456px" zoomAndPan="magnify"><defs></defs><g><!--class Autor--><g id="elem_Autor"><rect codeline="13" fill="none" height="92.8281" id="Autor" rx="2.5" ry="2.5" style="stroke:#000000;stroke-width:0.5;" width="216" x="7" y="7"></rect><ellipse cx="93.75" cy="23" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"></ellipse><path d="M96.5156,18.875 Q96.6719,18.6563 96.8594,18.5469 Q97.0469,18.4375 97.2656,18.4375 Q97.6406,18.4375 97.875,18.7031 Q98.1094,18.9531 98.1094,19.5625 L98.1094,21.0156 Q98.1094,21.625 97.875,21.8906 Q97.6406,22.1563 97.2656,22.1563 Q96.9219,22.1563 96.7188,21.9531 Q96.5156,21.7656 96.4063,21.25 Q96.3594,20.8906 96.1719,20.7031 Q95.8438,20.3281 95.2344,20.1094 Q94.625,19.8906 94,19.8906 Q93.2344,19.8906 92.5938,20.2188 Q91.9688,20.5469 91.4688,21.2969 Q90.9844,22.0469 90.9844,23.0781 L90.9844,24.1719 Q90.9844,25.4063 91.875,26.2344 Q92.7656,27.0469 94.3594,27.0469 Q95.2969,27.0469 95.9531,26.7969 Q96.3438,26.6406 96.7656,26.2031 Q97.0313,25.9375 97.1719,25.8594 Q97.3281,25.7813 97.5313,25.7813 Q97.8594,25.7813 98.1094,26.0469 Q98.375,26.2969 98.375,26.6406 Q98.375,26.9844 98.0313,27.3906 Q97.5313,27.9688 96.7344,28.2969 Q95.6563,28.75 94.3594,28.75 Q92.8438,28.75 91.6406,28.125 Q90.6563,27.625 89.9688,26.5625 Q89.2813,25.4844 89.2813,24.2031 L89.2813,23.0469 Q89.2813,21.7188 89.8906,20.5781 Q90.5156,19.4219 91.6094,18.8125 Q92.7031,18.1875 93.9375,18.1875 Q94.6719,18.1875 95.3125,18.3594 Q95.9688,18.5156 96.5156,18.875 Z " fill="#000000"></path><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="34" x="114.25" y="28.7285">Autor</text><line style="stroke:#000000;stroke-width:0.5;" x1="8" x2="222" y1="39" y2="39"></line><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="172" x="13" y="57.5332">-nombre : string {readOnly}</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="204" x="13" y="75.1426">-nacionalidad : string {readOnly}</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="198" x="13" y="92.752">-muerte : DateTime  {readOnly}</text></g><!--class Libro--><g id="elem_Libro"><rect codeline="20" fill="none" height="92.8281" id="Libro" rx="2.5" ry="2.5" style="stroke:#000000;stroke-width:0.5;" width="166" x="283" y="7"></rect><ellipse cx="345.75" cy="23" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"></ellipse><path d="M348.5156,18.875 Q348.6719,18.6563 348.8594,18.5469 Q349.0469,18.4375 349.2656,18.4375 Q349.6406,18.4375 349.875,18.7031 Q350.1094,18.9531 350.1094,19.5625 L350.1094,21.0156 Q350.1094,21.625 349.875,21.8906 Q349.6406,22.1563 349.2656,22.1563 Q348.9219,22.1563 348.7188,21.9531 Q348.5156,21.7656 348.4063,21.25 Q348.3594,20.8906 348.1719,20.7031 Q347.8438,20.3281 347.2344,20.1094 Q346.625,19.8906 346,19.8906 Q345.2344,19.8906 344.5938,20.2188 Q343.9688,20.5469 343.4688,21.2969 Q342.9844,22.0469 342.9844,23.0781 L342.9844,24.1719 Q342.9844,25.4063 343.875,26.2344 Q344.7656,27.0469 346.3594,27.0469 Q347.2969,27.0469 347.9531,26.7969 Q348.3438,26.6406 348.7656,26.2031 Q349.0313,25.9375 349.1719,25.8594 Q349.3281,25.7813 349.5313,25.7813 Q349.8594,25.7813 350.1094,26.0469 Q350.375,26.2969 350.375,26.6406 Q350.375,26.9844 350.0313,27.3906 Q349.5313,27.9688 348.7344,28.2969 Q347.6563,28.75 346.3594,28.75 Q344.8438,28.75 343.6406,28.125 Q342.6563,27.625 341.9688,26.5625 Q341.2813,25.4844 341.2813,24.2031 L341.2813,23.0469 Q341.2813,21.7188 341.8906,20.5781 Q342.5156,19.4219 343.6094,18.8125 Q344.7031,18.1875 345.9375,18.1875 Q346.6719,18.1875 347.3125,18.3594 Q347.9688,18.5156 348.5156,18.875 Z " fill="#000000"></path><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="32" x="366.25" y="28.7285">Libro</text><line style="stroke:#000000;stroke-width:0.5;" x1="284" x2="448" y1="39" y2="39"></line><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="154" x="289" y="57.5332">-titulo : string {readOnly}</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="128" x="289" y="75.1426">-año : int {readOnly}</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="154" x="289" y="92.752">-paginas : int {readOnly}</text></g><!--reverse link Autor to Libro--><g id="link_Autor_Libro"><path codeline="9" d="M235.04,53.5 C255.08,53.5 263.73,53.5 282.86,53.5 " fill="none" id="Autor-backto-Libro" style="stroke:#000000;stroke-width:1.0;"></path><polygon fill="none" points="223.04,53.5,229.04,57.5,235.04,53.5,229.04,49.5,223.04,53.5" style="stroke:#000000;stroke-width:1.0;"></polygon><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="7" x="230.8827" y="67.576">1</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="5" x="269.9651" y="67.7567">*</text></g><!--SRC=[VP31IiH038RlynIXHw6WLs_jUX44XLtmd7PY6tOwMJ8feaiVocVmnPnQ2iMLdKl8_D_y_oI1tWnCGBdh3JmhjSOINJfoFA7Y06t0b2epvMOqUcmbxlcJu7Q3LAholfCW2dN0zhYHNdAB7TMvT2fZz0lsshFHVf0ZRTZTd5IBUjB_pHRWZzL1CQQiKpJdgj7oLN5NW9Gb53S5F76ZubpFdfPHO23hnIVdblRtYJixoAU4A4EZ1FUGyi2nWxCI-kSOFgOLm3Rl1mDxz5UmOIIrsUS1ZGuy46oPQGrVVhU66ziOv8ehVd_DCaUxr4xOSSHqAK_k1m00]--></g></svg></p><p></p>
<blockquote>
<p>📌 <strong>Nota:</strong> Para simplificar, puedes descargarte el código de las clases y la carga inicial de datos del siguiente código <a href="https://programacioniesbalmis.github.io/B8-Programacion_Funcional/DatosAutoresTema_11_4_ejemplo.cs">DatosAutoresTema_11_4.cs</a>.</p>
</blockquote>
<p>El programa generará una <strong>secuencia de autores</strong> que mostrará al ejecutarse y que<br>
contendrá los siguientes autores:</p>
<pre data-role="codeBlock" data-info="txt" class="language-txt txt"><code>Nombre: William Shakespeare
Nacionalidad: Inglesa
Muerte: 03/05/1616
Libros:
        Titulo: Macbeth                                Año: 1623  Páginas: 128
        Titulo: La tempestad                           Año: 1611  Páginas: 160
</code></pre><pre data-role="codeBlock" data-info="txt" class="language-txt txt"><code>Nombre: Miguel de Cervantes
Nacionalidad: Española
Muerte: 22/06/1616
Libros:
        Titulo: Don Quijote de la Mancha               Año: 1605  Páginas: 1376
        Titulo: La Galatea                             Año: 1585  Páginas: 664
        Titulo: Los trabajos de Persiles y Sigismunda  Año: 1617  Páginas: 888
        Titulo: Novelas ejemplares                     Año: 1613  Páginas: 1160
</code></pre><pre data-role="codeBlock" data-info="txt" class="language-txt txt"><code>Nombre: Fernando de Rojas
Nacionalidad: Española
Muerte: 07/02/1541
Libros:
        Titulo: La Celestina                           Año: 1500  Páginas: 160
</code></pre><p>Con las funciones que hemos visto hasta el momento podríamos hacer consultas sobre los autores. Por ejemplo, para ver aquellos autores que han publicado algún libro en el siglo XVII podríamos hacer...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>Autor<span class="token punctuation">&gt;</span></span> autoresConLibrosPublicadosDuranteSigloXVII <span class="token operator">=</span>
Datos<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Libros<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>l <span class="token operator">=&gt;</span> l<span class="token punctuation">.</span>Año <span class="token operator">&gt;</span> <span class="token number">1600</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>Año <span class="token operator">&lt;</span> <span class="token number">1701</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Pero, si quisiéramos obtener los libros publicados en el siglo XVII a partir de la secuencia de autores. Ahora tendríamos un caso de uso de <strong><code>SelectMany</code></strong> (Flat Map):</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token comment">// IEnumerable&lt;Autor&gt; x (Autor → IEnumerable&lt;Libro&gt;) → IEnumerable&lt;Libro&gt;</span>
<span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>Libro<span class="token punctuation">&gt;</span></span> librosSigloXVII <span class="token operator">=</span>
Datos<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">SelectMany</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Libros<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>l <span class="token operator">=&gt;</span> l<span class="token punctuation">.</span>Año <span class="token operator">&gt;</span> <span class="token number">1600</span> <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>Año <span class="token operator">&lt;</span> <span class="token number">1701</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Incluso podríamos <strong>generar una correlación</strong> entre <strong><code>Libros</code></strong> y <strong><code>Autor</code></strong> proyectando cada libro que cumple la condición a una nueva secuencia de objetos anónimos o DTO que tuviese datos del autor del libro.</p>
<p>Por ejemplo, si quisiésemos obtener una vista libro, autor y número de páginas de aquellos libros que tienen menos de mil páginas y crear una secuencia tipada con un DTO podríamos hacer por ejemplo...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-record">record</span> <span class="token class-name">LibroDto</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> Libro<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword keyword-string">string</span></span> Autor<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword keyword-int">int</span></span> Paginas<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// IEnumerable&lt;Autor&gt; x (Autor → IEnumerable&lt;LibroDto&gt;) → IEnumerable&lt;LibroDto&gt;</span>
    <span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>LibroDto<span class="token punctuation">&gt;</span></span> <span class="token function">LibrosDeMenosdeMilPaginas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    Datos<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">SelectMany</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Libros
                                   <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>l <span class="token operator">=&gt;</span> l<span class="token punctuation">.</span>Paginas <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span>
                                   <span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>l <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">LibroDto</span><span class="token punctuation">(</span>
                                    <span class="token named-parameter punctuation">Libro</span><span class="token punctuation">:</span> l<span class="token punctuation">.</span>Titulo<span class="token punctuation">,</span> <span class="token named-parameter punctuation">Autor</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>Nombre<span class="token punctuation">,</span> <span class="token named-parameter punctuation">Paginas</span><span class="token punctuation">:</span> l<span class="token punctuation">.</span>Paginas<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Una vez tenemos la secuencia de salida con los objetos anónimos de la proyección. </span>
    <span class="token comment">// Podemos mostrarla en forma de tabla de la siguiente forma ...</span>
    <span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-string">string</span></span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>LibroDto<span class="token punctuation">&gt;</span></span> datos<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword keyword-string">string</span></span> separadorDato<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    datos<span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span>separadorDato<span class="token punctuation">,</span> 
                    <span class="token punctuation">(</span>salida<span class="token punctuation">,</span> tupla<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> 
                    salida <span class="token operator">+=</span> <span class="token interpolation-string"><span class="token string">$"Libro: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">tupla<span class="token punctuation">.</span>Libro</span><span class="token punctuation">}</span></span><span class="token string">\nAutor: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">tupla<span class="token punctuation">.</span>Autor</span><span class="token punctuation">}</span></span><span class="token string">\n"</span></span> <span class="token operator">+</span>
                              <span class="token interpolation-string"><span class="token string">$"Paginas: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">tupla<span class="token punctuation">.</span>Paginas</span><span class="token punctuation">}</span></span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">separadorDato</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Posteriormente si ejecutamos ...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>LibroDto<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span>LibroDto<span class="token punctuation">.</span><span class="token function">LibrosDeMenosdeMilPaginas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SeparadorDato<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Generando la siguiente salida por consola...</p>
<pre data-role="codeBlock" data-info="txt" class="language-txt txt"><code>--------------------------------------------------------------------------------
Libro: Macbeth
Autor: William Shakespeare
Paginas: 128
--------------------------------------------------------------------------------
Libro: La tempestad
Autor: William Shakespeare
Paginas: 160
--------------------------------------------------------------------------------
Libro: La Galatea
Autor: Miguel de Cervantes
Paginas: 664
--------------------------------------------------------------------------------
Libro: Los trabajos de Persiles y Sigismunda
Autor: Miguel de Cervantes
Paginas: 888
--------------------------------------------------------------------------------
Libro: La Celestina
Autor: Fernando de Rojas
Paginas: 160
--------------------------------------------------------------------------------
</code></pre><div style="page-break-after:always;"></div>
<blockquote>
<p>🎓 <strong>Caso de estudio:</strong></p>
<p>Vamos a realizar varias consultas sobre el código del ejemplo anterior donde tenemos libros por autor.<br>
✋ <strong>Intenta pensarlas sin mirar la propuesta de solución.</strong></p>
<ol>
<li>
<p>Autores con <strong>más de un</strong> libro.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-var">var</span></span> snapshot <span class="token operator">=</span> Datos<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Libros<span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span>SeparadorDato<span class="token punctuation">,</span>
                              <span class="token punctuation">(</span>salida<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> salida <span class="token operator">+=</span> <span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">a</span><span class="token punctuation">}</span></span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">SeparadorDato</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p>Total de libros escritos por escritores Españoles.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-var">var</span></span> totalLibros <span class="token operator">=</span> Datos<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Nacionalidad <span class="token operator">==</span> <span class="token string">"Española"</span><span class="token punctuation">)</span>
                               <span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>t<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> t <span class="token operator">+=</span> a<span class="token punctuation">.</span>Libros<span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Otra opción más legible utilizando SelectMany sería...</span>
<span class="token class-name"><span class="token keyword keyword-var">var</span></span> totalLibros <span class="token operator">=</span> Datos<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Nacionalidad <span class="token operator">==</span> <span class="token string">"Española"</span><span class="token punctuation">)</span>
                               <span class="token punctuation">.</span><span class="token function">SelectMany</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Libros<span class="token punctuation">)</span>
                               <span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Hay </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">totalLibros</span><span class="token punctuation">}</span></span><span class="token string"> escritos por españoles"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p>Muestra el <strong>nombre del autor</strong> y <strong>año de la muerte</strong> agrupando los autores por siglo en el que murieron en orden ascendente de siglo.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-var">var</span></span> snapShot <span class="token operator">=</span>
Datos<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token punctuation">{</span> Autor <span class="token operator">=</span> a<span class="token punctuation">.</span>Nombre<span class="token punctuation">,</span> AñoMuerte <span class="token operator">=</span> a<span class="token punctuation">.</span>Muerte<span class="token punctuation">.</span>Year <span class="token punctuation">}</span><span class="token punctuation">)</span>
             <span class="token punctuation">.</span><span class="token function">OrderBy</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>AñoMuerte<span class="token punctuation">)</span>
             <span class="token punctuation">.</span><span class="token function">GroupBy</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>AñoMuerte <span class="token operator">/</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
                      <span class="token punctuation">(</span>siglo<span class="token punctuation">,</span> autores<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword keyword-new">new</span> <span class="token punctuation">{</span> Siglo <span class="token operator">=</span> siglo<span class="token punctuation">,</span> Autores <span class="token operator">=</span> autores <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>snapShot<span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span>SeparadorDato<span class="token punctuation">,</span> <span class="token punctuation">(</span>salida<span class="token punctuation">,</span> aXs<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
salida <span class="token operator">+=</span> <span class="token interpolation-string"><span class="token string">$"Siglo: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">aXs<span class="token punctuation">.</span>Siglo</span><span class="token punctuation">}</span></span><span class="token string">\n"</span></span> 
<span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">aXs<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">Aggregate</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> 
                           <span class="token punctuation">(</span>t<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token operator">=&gt;</span> t <span class="token operator">+=</span> <span class="token interpolation-string"><span class="token string">$"\t</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">a<span class="token punctuation">.</span>Autor</span><span class="token punctuation">}</span></span><span class="token string"> muerto en </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">a<span class="token punctuation">.</span>AñoMuerte</span><span class="token punctuation">}</span></span><span class="token string">\n"</span></span><span class="token punctuation">)</span>
    </span><span class="token punctuation">}</span></span><span class="token string">"</span></span> <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">SeparadorDato</span><span class="token punctuation">}</span></span><span class="token string">"</span></span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>✋ <strong>Importante:</strong> Aunque en este caso hemos utilizado programación funcional para mostrar el resultado. Este sería el típico caso donde <strong>por legibilidad</strong> y <strong>claridad de código</strong> sería más interesante usar el esquema tradicional de componer un <strong><code>StringBuilder</code></strong> con bucles.</p>
</li>
</ol>
</blockquote>
<div style="page-break-after:always;"></div>
<blockquote>
<ol start="4">
<li>
<p>Numero <strong>total de páginas escritas</strong> por <strong>William Shakespeare</strong>.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-var">var</span></span> totalPaginas <span class="token operator">=</span>
Datos<span class="token punctuation">.</span>Autores<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Nombre <span class="token operator">==</span> <span class="token string">"William Shakespeare"</span><span class="token punctuation">)</span>
             <span class="token punctuation">.</span><span class="token function">SelectMany</span><span class="token punctuation">(</span>a <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>Libros<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>l <span class="token operator">=&gt;</span> l<span class="token punctuation">.</span>Paginas<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"William Shakespeare escribió </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">totalPaginas</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li>
</ol>
</blockquote>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>