<!DOCTYPE html><html><head>
      <title>Programación 1º DAM Tema 6</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
@font-face {
  font-family: 'Catamaran';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/catamaran/v19/o-0bIpQoyXQa2RxT7-5B6Ryxs2E_6n1iPHjd5a7dvg.ttf) format('truetype');
}
.markdown-preview.markdown-preview .caso_estudio {
  background-color: #f5f5f5;
  border: 2px solid #969696;
  padding: 15px;
  margin-top: 15px;
  margin-bottom: 15px;
  border-radius: 5px;
  box-shadow: 0 0 7px 0 rgba(78, 120, 158, 0.1);
}
.markdown-preview.markdown-preview .resumen {
  background-color: #d6d6d6;
  border: 2px solid #b0b0b0;
  padding: 15px;
  margin-top: 15px;
  margin-bottom: 15px;
  border-radius: 5px;
  box-shadow: 0 0 7px 0 rgba(78, 120, 158, 0.1);
}
.markdown-preview.markdown-preview .ejercicio {
  background-color: #f5faf5;
  border: 2px solid #969b96;
  padding-left: 15px;
  padding-right: 15px;
  margin-top: 15px;
  margin-bottom: 15px;
  border-radius: 5px;
  box-shadow: 0 0 7px 0 rgba(78, 120, 158, 0.1);
}
.markdown-preview.markdown-preview .contenedor {
  display: flex;
  justify-content: center;
  margin: 30px auto 30px auto;
}
.markdown-preview.markdown-preview .fondo {
  background: url(https://programacioniesbalmis.github.io/Imagenes/BannersMoodle/banner.png);
  background-size: cover;
  width: 75%;
  height: 160px;
  border-radius: 10px;
  position: relative;
}
.markdown-preview.markdown-preview .cita {
  font-family: Arial;
  font-style: italic;
  font-weight: 600;
  text-align: justify;
  line-height: 1.5rem;
  opacity: 0.6;
  color: white;
  padding: 5rem;
  position: relative;
  top: 50%;
  left: 50%;
  font-size: 1.3rem;
  transform: translate(-50%, -50%);
}
.markdown-preview.markdown-preview .abre_comilla {
  font-family: "Catamaran";
  font-weight: 600;
  color: white;
  padding-left: 30px;
  position: absolute;
  font-size: 6rem;
  transform: translate(0%, -15%);
}
.markdown-preview.markdown-preview .cierra_comilla {
  font-family: "Catamaran";
  font-weight: 600;
  color: white;
  padding-right: 30px;
  right: 0%;
  position: absolute;
  font-size: 6rem;
  transform: translate(0%, 55%);
}
.markdown-preview.markdown-preview .autor {
  font-family: Arial;
  color: white;
  margin: 0px;
  padding-left: 30px;
  position: absolute;
  top: 83%;
  font-size: 1rem;
}
.markdown-preview.markdown-preview .flotante {
  display: flex;
  justify-content: space-between;
  margin-top: 15px;
  margin-bottom: 15px;
}
@media (max-width: 550px) {
  .markdown-preview.markdown-preview .flotante {
    flex-direction: column;
  }
}
@media (min-width: 550px) {
  .markdown-preview.markdown-preview .flotante {
    flex-direction: row;
  }
}
.markdown-preview.markdown-preview .flotante_izq {
  margin-right: 15px;
}
@media (max-width: 550px) {
  .markdown-preview.markdown-preview .flotante_izq {
    width: 100%;
  }
}
@media (min-width: 550px) {
  .markdown-preview.markdown-preview .flotante_izq {
    width: auto;
  }
}
@media (max-width: 550px) {
  .markdown-preview.markdown-preview .flotante_der {
    width: 100%;
  }
}
@media (min-width: 550px) {
  .markdown-preview.markdown-preview .flotante_der {
    width: auto;
  }
}

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="tema-6">Tema 6 </h1>
<p>Descargar estos apuntes en <a href="./Tema6.pdf">pdf</a> o <a href="./Tema6.html">html</a></p>
<h2 id="índice">Índice </h2>

<div class="md-toc">
<div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:18px">
          <a href="#índice" class="md-toc-link">
            <p>Índice</p>

          </a></div><details style="padding:0;;padding-left:0px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#expresiones-regulares-en-csharp" class="md-toc-link"><p>Expresiones Regulares en CSharp</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#definición-de-expresión-regular" class="md-toc-link">
            <p>Definición de expresión regular</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#caracteres" class="md-toc-link">
            <p>Caracteres</p>

          </a></div><details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#metacaracteres" class="md-toc-link"><p>Metacaracteres</p>
</a>
          </summary>
        <div>
          <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#clases-de-carácter" class="md-toc-link"><p>Clases de carácter</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#alternancia-de-carácter" class="md-toc-link">
            <p>Alternancia de carácter</p>

          </a></div>
        </div>
      </details>
    <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#alternancia-de-expresiones" class="md-toc-link">
            <p>Alternancia de expresiones</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#aserciones-atómicas-de-ancho-cero" class="md-toc-link">
            <p>Aserciones atómicas de ancho cero</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#construcciones-de-agrupamiento-o-grupos" class="md-toc-link">
            <p>Construcciones de agrupamiento o grupos</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#cuantificadores" class="md-toc-link">
            <p>Cuantificadores</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#construcciones-de-referencia-inversa" class="md-toc-link">
            <p>Construcciones de referencia inversa</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#uso-de-expresiones-regulares-en-el-lenguaje" class="md-toc-link"><p>Uso de expresiones regulares en el lenguaje</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#métodos-de-utilidad-sobre-cadenas-usando-er" class="md-toc-link">
            <p>Métodos de utilidad sobre cadenas usando ER</p>

          </a></div><details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#gestión-de-grupos-con-o-sin-etiqueta" class="md-toc-link"><p>Gestión de grupos con o sin etiqueta</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#buscar-una-ocurrencia-concreta-con-un-patrón" class="md-toc-link">
            <p>Buscar una ocurrencia concreta con un patrón</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#buscar-todas-las-ocurrencias-de-un-patrón" class="md-toc-link">
            <p>Buscar todas las ocurrencias de un patrón</p>

          </a></div>
        </div>
      </details>
    
        </div>
      </details>
    
        </div>
      </details>
    
</div>
<div style="page-break-after:always;"></div>
<h2 id="expresiones-regulares-en-csharp">Expresiones Regulares en CSharp </h2>
<p>Para probar las expresiones regulares '<em>on-line</em>' podemos usar la siguiente url <a href="https://regexr.com/" target="_blank">regexr.com</a></p>
<h3 id="definición-de-expresión-regular">Definición de expresión regular </h3>
<p>Una expresión regular, a menudo llamada también <strong>patrón</strong>, es una expresión representada por <strong>caracteres</strong> y <strong>metacaracteres</strong> que describe un <strong>conjunto de cadenas</strong> sin enumerar sus elementos.<br>
A través de la expresión regular es posible interpretar rápidamente vastas cantidades de texto y ejecutar varias operaciones como:</p>
<ul>
<li>Buscar patrones.</li>
<li>Eliminar texto.</li>
<li>Extraer patrones.</li>
</ul>
<h3 id="caracteres">Caracteres </h3>
<p>Será todo lo que no sean metacaracteres. Coinciden en la expresión con ellos mismos.</p>
<h3 id="metacaracteres">Metacaracteres </h3>
<p>Son caracteres que tienen cierto significado especial '*', '?', etc.</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>root<span class="token comment"># ls *.odt</span>
</code></pre><p>En el enlace del tema podrás ver la especificación oficial del la sintaxis soportada por C# para expresiones regulares. Nosotros en este tema hemos hecho un <strong>'<em>resumen</em>'</strong> con las características más comunes de las mismas y que podrás encontrar en la mayoría de lenguajes.</p>
<div style="page-break-after:always;"></div>
<h4 id="clases-de-carácter">Clases de carácter </h4>
<p>Son conjuntos de caracteres que encontrarán una correspondencia si uno de los caracteres incluido en el conjunto coincide.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Metacaracter</th>
<th style="text-align:left">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>.</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter menos \n.  Para poner '.'  usaremos \.</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>[aeiou]</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter dentro del grupo</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>[^aeiou]</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter que no pertenezca al grupo</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>[0-9]</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter dentro del rango indicado</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>[0-9A-Z]</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter dentro del rango indicado, con espacio</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\w</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter de palabra <strong><code>[a-zA-Z0-9]</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\W</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter de no-palabra</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\s</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter de espacio</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\S</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter de no-espacio</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\uNNNN</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter Unicode. Por ejemplo, <strong><code>\u00A9</code></strong> significa ©</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\d</code></strong></td>
<td style="text-align:left">Coincide con cualquier dígito. Otra manera es usar <strong><code>[0-9]</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\D</code></strong></td>
<td style="text-align:left">Coincide con cualquier no-dígito. Otra manera es usar <strong><code>[^0-9]</code></strong></td>
</tr>
</tbody>
</table>
<h5 id="alternancia-de-carácter">Alternancia de carácter </h5>
<p>C# los denomina también <a href="https://docs.microsoft.com/es-es/dotnet/standard/base-types/character-classes-in-regular-expressions#positive-character-group--">'grupo de caracteres positivos'</a>.<br>
La obtendremos con los corchetes <strong><code>[&lt;caracter1&gt;&lt;caracter2&gt;...]</code></strong></p>
<blockquote>
<p>📌 <strong>Nota:</strong> Los metacaracteres en el corchete no será interpretados como tales sino como los caracteres tal cual <strong><code>*, $, +, ?, |</code></strong> … salvo el caso de algunas clases de carácter como <strong><code>\d, \D, \w, \W, \s, \S</code></strong> y por tanto la barra de escape <strong><code>\</code></strong> deberemos escaparla si queremos que se interpreta tal cual.</p>
<p>✋ <strong>Importante:</strong> En ocasiones en C# si queremos definir alternancia de caracteres o un grupo de caracteres positivos donde tengamos clases de caracter estas <strong>deberán ir al principio del grupo</strong>. Por ejemplo, <strong><code>@"[\sa-z]"</code></strong> sería alternancia de un caracter de espacio o una letra minúscula. Sin embargo, <strong><code>@"[a-z\s]"</code></strong> que funcionaría en otros lenguajes podría generarnos errores en ejecución 💀</p>
</blockquote>
<div style="page-break-after:always;"></div>
<h4 id="alternancia-de-expresiones">Alternancia de expresiones </h4>
<p>Nos sirve para indicar una de varias opciones entre varias expresiones regulares, separadas por el metacaracter barra vertical <strong><code>|</code></strong> (<code>Alt + 124</code> o <code>Alt Gr + 4 y espacio</code>).</p>
<div class="caso_estudio">
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>este|oeste|norte|sur</code></strong> → Permitirá encontrar cualquiera de los nombres de los puntos cardinales.</li>
<li><strong><code>\b(mi|[ts]u)\b</code></strong> → Permitirá encontrar pronombres posesivos.</li>
</ol>
</div>
<h4 id="aserciones-atómicas-de-ancho-cero">Aserciones atómicas de ancho cero </h4>
<p>No hacen avanzar el motor a través de la cadena de consumo. Simplemente producen coincidencia o error en función de la posición actual en la cadena.</p>
<table>
<thead>
<tr>
<th>Metacaracter</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>^</code></strong></td>
<td>Especifica que la coincidencia debe producirse al principio de la cadena o de la línea.</td>
</tr>
<tr>
<td><strong><code>$</code></strong></td>
<td>Especifica que la coincidencia debe producirse al final de la cadena, antes de <strong><code>\n</code></strong> o al final de la línea.</td>
</tr>
<tr>
<td><strong><code>\A</code></strong></td>
<td>La coincidencia se debe producir al principio de la cadena.</td>
</tr>
<tr>
<td><strong><code>\Z</code></strong></td>
<td>La coincidencia se debe producir al final de la cadena.</td>
</tr>
<tr>
<td><strong><code>\b</code></strong></td>
<td>La coincidencia debe producirse en límites de palabras separadas por caracteres no alfanumérico (letras y números).</td>
</tr>
<tr>
<td><strong><code>\B</code></strong></td>
<td>Especifica que la coincidencia <strong>no</strong> se debe producir en un límite <strong><code>\b</code></strong>.</td>
</tr>
</tbody>
</table>
<div class="caso_estudio">
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>^\d$</code></strong> → Permite asegurar de que la cadena a verificar representa un único dígito, sin nada antes y después.</li>
<li><strong><code>^\d\d\/\d\d\/\d\d\d\d$</code></strong> → Permite validar un formato de fecha, aunque no permite verificar si es una fecha válida, ya que 99/99/9999 también sería válido en este formato.<br>
📌 <strong>Nota:</strong> Aunque C# no lo necesita, es conveniente escapar la barra <strong><code>"/"</code></strong> ya que en otros lenguajes cómo JavaScript es necesario por tanto pondremos <strong><code>@"\/"</code></strong>.</li>
</ol>
</div>
<div style="page-break-after:always;"></div>
<h4 id="construcciones-de-agrupamiento-o-grupos">Construcciones de agrupamiento o grupos </h4>
<p>Las construcciones de agrupamiento <strong>permiten capturar grupos de sub-expresiones</strong>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Metacaracter</th>
<th style="text-align:left">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>(e)</code></strong></td>
<td style="text-align:left">Captura la subcadena coincidente o grupo sin captura. Las capturas que utilizan <strong><code>()</code></strong> se numeran automáticamente en función del orden del paréntesis de apertura, comenzando por el número uno. La primera captura, la captura de elemento número cero, es el texto que coincide con el modelo completo de la expresión regular.</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>(?&lt;nombre&gt;e)</code></strong></td>
<td style="text-align:left">Captura la subcadena coincidente dentro de un nombre de grupo o nombre de número. La cadena que se utiliza para nombre no debe contener ningún signo de puntuación y no puede comenzar por un número.</td>
</tr>
</tbody>
</table>
<div class="caso_estudio">
<p><strong>Ejemplos:</strong></p>
<ol>
<li>
<p><strong><code>al (norte|sur) de</code></strong> → Permite crear un grupo sin captura para norte y sur representando las cadenas <em>…al <strong>norte</strong> de…</em> y <em>…al <strong>sur</strong> de…</em><br>
<img src="assets\norte_sur.png?0.889669541322287" alt=""></p>
</li>
<li>
<p><strong><code>^(?&lt;dia&gt;\d\d)\/(?&lt;mes&gt;\d\d)\/(?&lt;año&gt;\d\d\d\d)$</code></strong> → Busca la coincidencia exacta con una fecha. Pero <strong>además tendremos 3 grupos etiquetados</strong> con las sub-expresiones encontradas en dia, mes y año.</p>
<p>✋ <strong>Importante:</strong> En C# en el momento que etiquetamos un grupo, <strong>deberemos etiquetar el resto también</strong> o la expresión no será válida.</p>
</li>
</ol>
</div>
<div style="page-break-after:always;"></div>
<h4 id="cuantificadores">Cuantificadores </h4>
<p>Los cuantificadores agregan datos de cantidades opcionales a una expresión regular. Una expresión de cuantificador se aplica al carácter, grupo o clase de caracteres que lo precede inmediatamente.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Metacaracter</th>
<th style="text-align:left">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>e*</code></strong></td>
<td style="text-align:left">Especifica 0 o más coincidencias</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e+</code></strong></td>
<td style="text-align:left">Especifica 1 o más coincidencias</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e?</code></strong></td>
<td style="text-align:left">Especifica 0 o 1 coincidencias</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e{n}</code></strong></td>
<td style="text-align:left">Especifica exactamente n coincidencias</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e{n,}</code></strong></td>
<td style="text-align:left">Especifica n coincidencias como mínimo.</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e{n,m}</code></strong></td>
<td style="text-align:left">Especifica n coincidencias como mínimo y m como máximo.</td>
</tr>
</tbody>
</table>
<div class="caso_estudio">
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>^bo+m{1,4}$</code></strong> → Onomatopeya de explosión.<br>
<img src="assets\boom.png?0.14865586946760745" alt="" height="100"></li>
<li><strong><code>^\d{1,2}\/\d{1,2}\/\d{4}$</code></strong> → Fecha.<br>
<img src="assets\fecha.png?0.613838833254291" alt="" height="90"></li>
<li><strong><code>\b(?&lt;usuario&gt;[\w._%-]+)@(?&lt;dominio&gt;[\w._]+\.[a-zA-Z]{2,4})\b</code></strong> → Correo electrónico (Simplificado).<br>
<img src="assets\correo.png?0.6997489966603943" alt="" height="200"></li>
</ol>
</div>
<div style="page-break-after:always;"></div>
<h4 id="construcciones-de-referencia-inversa">Construcciones de referencia inversa </h4>
<p>Una <a href="https://docs.microsoft.com/es-es/dotnet/standard/base-types/backreference-constructs-in-regular-expressions" target="_blank">construcción referencia inversa</a> permite identificar una sub-expresión coincidente previamente más adelante en la misma expresión regular.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Metacaracter</th>
<th style="text-align:left">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>\1</code></strong></td>
<td style="text-align:left">Referencia inversa. Coincide con el valor de una sub-expresión numerada 1… n.</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\k&lt;nombre&gt;</code></strong></td>
<td style="text-align:left">Referencia inversa. Coincide con el valor de una sub-expresión con nombre.</td>
</tr>
</tbody>
</table>
<div class="caso_estudio">
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>(\w)\1</code></strong> → Devolverá '<em>aa</em>' en <em>'<strong>aa</strong>ron'</em></li>
<li><strong><code>(?&lt;letra&gt;\w)\k&lt;letra&gt;</code></strong> → Devolverá '<em>aa</em>' en <em>'<strong>aa</strong>ron'</em></li>
<li>Su pongamos esta expresión para detectar fechas:<br>
<strong><code>^\d{1,2}[\s\/-]\d{1,2}[\s\/-]\d{2,4}$</code></strong> Si nos fijamos la separación entre los valores de día, mes y año pueden ser diferentes por lo que podrían ser válidas entradas como: <strong>22/03-2021</strong> y <strong>3-12 2021</strong> pero... <strong>¿Cómo hacernos para asegurarnos que el separador que se ponga entre mes y año sea el mismo que se consumió entre día y mes?</strong>
<ul>
<li>Lo que quiero ver si se repite o no más adelante, lo pondré en un grupo.</li>
<li>Haré referencia al grupo con los ejemplos que hemos visto más adelante.<br>
Tendremos pues la espresión <strong><code>^\d{1,2}([\s\/-])\d{1,2}\1\d{2,4}$</code></strong><br>
<img src="assets\fecha2.png?0.5087048617354442" alt="" height="150"></li>
</ul>
</li>
</ol>
</div>
<div style="page-break-after:always;"></div>
<h3 id="uso-de-expresiones-regulares-en-el-lenguaje">Uso de expresiones regulares en el lenguaje </h3>
<p>Utilizaremos la clase de las BCL <strong><code>Regex</code></strong> definida en el espacio de nombres <strong><code>System.Text.RegularExpressions</code></strong>, que contendrá métodos estáticos para usarlas.</p>
<p>A la hora de usar el patrón podemos indicar mediante una serie de flags definidos en el enumerado <a href="https://docs.microsoft.com/es-es/dotnet/api/system.text.regularexpressions.regexoptions?redirectedfrom=MSDN&amp;view=netcore-3.1#campos">RegexOptions</a>, cómo se va a comportar el motor de expresiones regulares.</p>
<div class="caso_estudio">
<p><strong>Ejemplos:</strong><br>
Comprobación símple de la e.r. para comprobar un e-mail anterior.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"Introduce una e-mail: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> correo <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Las opciones del enumerado para el motor de e.r. serán un grupo de flags.</span>
    <span class="token class-name">RegexOptions</span> opciones <span class="token operator">=</span> RegexOptions<span class="token punctuation">.</span>Compiled <span class="token operator">|</span> RegexOptions<span class="token punctuation">.</span>IgnoreCase<span class="token punctuation">;</span> 
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patron <span class="token operator">=</span> <span class="token string">@"^[\w.%-]+@[\w.-]+\.[a-zA-Z]{2,4}$"</span><span class="token punctuation">;</span>
    
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> correoValido <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>correo<span class="token punctuation">,</span> patron<span class="token punctuation">,</span> opciones<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"El correo </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">correo</span><span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp"><span class="token punctuation">(</span><span class="token operator">!</span>correoValido <span class="token punctuation">?</span> <span class="token string">"no "</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string">es válido."</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div style="page-break-after:always;"></div>
<p>También también podemos instanciar un objeto de la clase RegEx por si nos interesara aplicar diferentes operaciones sobre el mismo patrón.</p>
<div class="caso_estudio">
<p><strong>Ejemplos:</strong><br>
Igual que el <strong>ejemplo 1</strong> pero rehusando un objeto instanciado de <strong><code>RegEx</code></strong>.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> correoValido<span class="token punctuation">;</span>
    <span class="token class-name">Regex</span> patron <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">Regex</span><span class="token punctuation">(</span><span class="token string">@"^[\w.%-]+@[\w.-]+\.[a-zA-Z]{2,6}$"</span><span class="token punctuation">,</span>
                                RegexOptions<span class="token punctuation">.</span>Compiled <span class="token operator">|</span> RegexOptions<span class="token punctuation">.</span>IgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-do">do</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"Introduce una dirección de correo: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> correo <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        correoValido <span class="token operator">=</span> patron<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>correo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>correoValido<span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">correo</span><span class="token punctuation">}</span></span><span class="token string"> no es un correo válido."</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>correoValido<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div style="page-break-after:always;"></div>
<h4 id="métodos-de-utilidad-sobre-cadenas-usando-er">Métodos de utilidad sobre cadenas usando ER </h4>
<p>Destacaremos un par de ellos,  tendremos la posibilidad de usarlos tanto sobre un objeto instanciado o como métodos de clase estáticos (nosotros vamos a ver estos últimos).</p>
<ul>
<li>
<p><strong><code>static string Replace(string cadenaConsumo, string patrón, string reemplazo, RegexOptions opciones)</code></strong><br>
Reemplaza un patrón en la cadena de consumo por una cadena de reemplazo.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-string">string</span></span> texto1 <span class="token operator">=</span> <span class="token string">"Esta   es una    cadena    con "</span> <span class="token operator">+</span>
                <span class="token string">"un  número de     espacios en blanco indeterminado."</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>texto1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-string">string</span></span> texto2 <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span>texto1<span class="token punctuation">,</span> <span class="token string">@"\s+"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>texto2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li>
<li>
<p><strong><code>static string[] Split(string cadenaConsumo, string patrón, RegexOptions opciones)</code></strong><br>
Trocea una cadena por un patrón.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token class-name"><span class="token keyword keyword-string">string</span></span> texto <span class="token operator">=</span> <span class="token string">"Esta   es una    cadena    con "</span> <span class="token operator">+</span>
               <span class="token string">"un  número de     espacios en blanco indeterminado."</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> palabras <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>texto<span class="token punctuation">,</span> <span class="token string">@"\s+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">,</span> palabras<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></li>
</ul>
<h4 id="gestión-de-grupos-con-o-sin-etiqueta">Gestión de grupos con o sin etiqueta </h4>
<p>Utilizaremos la clase <a href="https://docs.microsoft.com/es-es/dotnet/api/system.text.regularexpressions.match?view=netcore-3.1" target="_blank">Match</a> que además de contener información de los grupos, me ayudará a gestionar <strong>coincidencias</strong>.</p>
<ul>
<li>
<p>Como ha sucedido hasta ahora, obtendremos un objeto Match a partir de una instancia de objeto <strong><code>RegEx</code></strong> o directamente a través de un método de clase de RegEx:</p>
<ul>
<li><strong><code>Match objRegex.Match(string cadenaDeEntrada);</code></strong></li>
<li><strong><code>static Match RegEx.Match(string cadenaDeEntrada, string patrón);</code></strong></li>
</ul>
</li>
<li>
<p>Una vez tenemos un objeto <strong><code>Match</code></strong>...</p>
<ul>
<li>Dispondremos de la propiedad <strong><code>bool objMatch.Success</code></strong> que medirá si se encontró una coincidéncia o no (del grupo principal).</li>
<li>Dispondremos de la propiedad <strong><code>bool objMatch.Groups</code></strong> que podremos indizar a través de un entero o de una cadena con la etiqueta del grupo, y nos devolverá el grupo correspondiente.</li>
<li>Dispondremos del método de instancia <strong><code>Match objMatch.NextMatch()</code></strong> que continuará buscando coincidencias de la ER que generó el objeto match al que se le aplico.</li>
</ul>
</li>
<li>
<p>Una vez tenemos un objeto <strong><code>Group</code></strong> indizado...</p>
<ul>
<li>Dispondremos de la propiedad <strong><code>string objGroup.Value</code></strong> que me devolverá un string con la coincidéncia encontrada.</li>
</ul>
</li>
</ul>
<div style="page-break-after:always;"></div>
<div class="caso_estudio">
<p><strong>Ejemplos:</strong></p>
<p>Veamos su funcionamiento a través de un programa de ejemplo en el que vamos a pedir una fecha con formato <strong><code>dd/mm/aaaa</code></strong> y además de ver si es correcta la entrada, vamos a mostrar los valores de día, més y año introducidos.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"Introduce una fecha dd/mm/aaaa: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> fecha <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token class-name">Regex</span> patronFecha <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">Regex</span><span class="token punctuation">(</span><span class="token string">@"^(?&lt;Dia&gt;\d{2})\/(?&lt;Mes&gt;\d{2})\/(?&lt;Año&gt;\d{4})$"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Busco la primera y única coincidencia en la cadena de consumo fecha.</span>
    <span class="token class-name">Match</span> coincidencia <span class="token operator">=</span> patronFecha<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>fecha<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Sabemos con 'seguridad' que en los grupos hay valores numéricos</span>
        <span class="token comment">// En este ejemplo como los grupos estaban etiquetados, puedo indexar</span>
        <span class="token comment">// utilizando el nombre de la etiqueta del grupo.</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> dia <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token string">"Dia"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> mes <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token string">"Mes"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-ushort">ushort</span> año <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token string">"Año"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Dia = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">dia</span><span class="token punctuation">}</span></span><span class="token string">, Mes = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">mes</span><span class="token punctuation">}</span></span><span class="token string"> y Año = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">año</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"No ha introducido un formato de fecha válido."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div style="page-break-after:always;"></div>
<h5 id="buscar-una-ocurrencia-concreta-con-un-patrón">Buscar una ocurrencia concreta con un patrón </h5>
<p>Vamos a modificar ligéramente el ejemplo anterior, para que a partir de la cadena <strong>"<em>El 11/9/2001 fueron derribadas las torres gemelas de NY y el 20/7/1969 llegó el hombre a la luna</em>"</strong> me diga si en la misma se encuentra la fecha de la llegada del hombre a la luna con formato <strong><code>dd/mm/aaaa</code></strong> pero esta vez <strong><code>dd</code></strong> y <strong><code>mm</code></strong> pueden estar formados también por una solo dígito y <strong>los grupos NO estarán etiquetados</strong>.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> texto  <span class="token operator">=</span> <span class="token string">"El 11/9/2001 fueron derribadas las torres gemelas "</span> <span class="token operator">+</span> 
                    <span class="token string">"de NY y el 20/7/1969 llegó el ombre a la luna"</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patron <span class="token operator">=</span> <span class="token string">@"(\d{1,2})\/(\d{1,2})\/(\d{4})"</span><span class="token punctuation">;</span>
    <span class="token class-name">Match</span> coincidencia    <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>texto<span class="token punctuation">,</span> patron<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span>  fechaEncontrada <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// Mientras no encuentre lo que busco y </span>
    <span class="token comment">// haya coincidencias con el patrón que busco en la cadena.</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fechaEncontrada <span class="token operator">&amp;&amp;</span> coincidencia<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> fecha <span class="token operator">=</span> coincidencia<span class="token punctuation">.</span>Value<span class="token punctuation">;</span> <span class="token comment">// Equivale a coincidencia.Groups[0].Value</span>
        <span class="token comment">// Cada paréntesis en la expresión para definir un grupo se numerarán </span>
        <span class="token comment">// de izquierda a derecha empezando por 1 ya que el índice 0 es toda la expresión.</span>
        <span class="token comment">// Puede ser una opción si tenemos pocos grupos pero no anidados, </span>
        <span class="token comment">// aunque será menos legible que la anterior.</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> dia <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> mes <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-ushort">ushort</span> año <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fechaEncontrada <span class="token operator">=</span> dia <span class="token operator">==</span> <span class="token number">20</span> <span class="token operator">&amp;&amp;</span> mes <span class="token operator">==</span> <span class="token number">7</span> <span class="token operator">&amp;&amp;</span> año <span class="token operator">==</span> <span class="token number">1969</span><span class="token punctuation">;</span>
        <span class="token comment">// NextMatch busca la siguiente coincidéncia si la hay </span>
        <span class="token comment">// a partir de la la última que encontró.</span>
        coincidencia <span class="token operator">=</span> coincidencia<span class="token punctuation">.</span><span class="token function">NextMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"La fecha de la llegada a la luna </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp"><span class="token punctuation">(</span>fechaEncontrada<span class="token punctuation">?</span><span class="token string">"no se"</span><span class="token punctuation">:</span><span class="token string">"se"</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string"> "</span></span> <span class="token operator">+</span>
                       <span class="token string">"encuentra en el texto"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div style="page-break-after:always;"></div>
<h5 id="buscar-todas-las-ocurrencias-de-un-patrón">Buscar todas las ocurrencias de un patrón </h5>
<ul>
<li>Usaremos el método <strong><code>Regex.Matches(cadena, patrón, ...)</code></strong> que me devolverá una colección indexable y recorrible con <strong><code>foreach</code></strong> con todas las coincidencias.</li>
<li>Este caso será útil, si queremos obtener <strong>todas</strong> las coincidencias, y no una en concreto que puede que la encontremos justo al principio, con lo cual esta opción sería más costosa.</li>
</ul>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-foreach">foreach</span><span class="token punctuation">(</span><span class="token class-name">Match</span> coincidencia <span class="token keyword keyword-in">in</span> Regex<span class="token punctuation">.</span><span class="token function">Matches</span><span class="token punctuation">(</span>texto<span class="token punctuation">,</span> patron<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> fecha <span class="token operator">=</span> coincidencia<span class="token punctuation">.</span>Value<span class="token punctuation">;</span> <span class="token comment">// Equivale a coincidencia.Groups[0].Value</span>
    <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> dia <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> mes <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-ushort">ushort</span> año <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Fecha encontrada </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">fecha</span><span class="token punctuation">}</span></span><span class="token string"> Dia = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">dia</span><span class="token punctuation">}</span></span><span class="token string">, Mes = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">mes</span><span class="token punctuation">}</span></span><span class="token string"> y Año = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">año</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="caso_estudio">
<p>🎓 <strong>Caso de estudio:</strong></p>
<p>Supongamos que queremos hacer un método de utilidad que nos diga si una <strong>IP</strong> de entrada es correcta.<br>
Además, usaremos ese método como apoyo a otro que lea una IP desde teclado y filtre solo valores válidos.<br>
<strong>Nota:</strong> Una <strong>IP</strong> esta formada por <strong>cuatro bytes</strong> separados por punto de <strong><code>0</code></strong> a <strong><code>255</code></strong> por ejemplo <strong><code>10.0.2.254</code></strong><br>
Una primera aproximación, podría ser dar como válidas tres secuencias de <strong>1 a 3 dígitos</strong> separadas por un <strong><code>.</code></strong> con nada antes <strong><code>^</code></strong> y después <strong><code>$</code></strong>. Por tanto el patrón podría quedar algo así:<br>
<strong><code>^\d{1,3}\.\d{1,3}\.\d{1,3}.\d{1,3}$</code></strong>.<br>
Fíjate, que hemos escapado el caracter <strong><code>'.'</code></strong> por ser un metacaracter de las clase de caracter y queremos se interprete de forma literal.<br>
A primera vista, se repiten tres partes en la expresión compuestas por el caracter <strong><code>'.'</code></strong> seguido de 3 dígitos, por lo que podríamos simplificar la expresión así:<br>
<strong><code>^\d{1,3}(\.\d{1,3}){3}$</code></strong><br>
Fíjate, para indicar que lo que se repite 3 veces es eso hemos tenido que agruparlo en una sub-expresión.<br>
Una vez hemos decidido la expresión regular nuestro código podría quedar así.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">Programa</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">@"^\d{1,3}(\.\d{1,3}){3}$"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-string">string</span></span> <span class="token function">LeeIP</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> mensaje<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-bool">bool</span> válida<span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> ip<span class="token punctuation">;</span>
        <span class="token keyword keyword-do">do</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">mensaje</span><span class="token punctuation">}</span></span><span class="token string">: "</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ip <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            válida <span class="token operator">=</span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>válida<span class="token punctuation">)</span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"IP </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">ip</span><span class="token punctuation">}</span></span><span class="token string"> no es válida."</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>válida<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword keyword-return">return</span> ip<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> ip <span class="token operator">=</span> <span class="token function">LeeIP</span><span class="token punctuation">(</span><span class="token string">"Introduce la IP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"La IP introducida es </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">ip</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Pero... <strong>¿Es posible controlar que los bytes estén entre 0 y 255 en la propia expresión?</strong><br>
En este caso tendremos que indicar algún tipo de alternancia de posibilidades para incluir rángos excluyentes en la expresión...</p>
<ol>
<li>Podemos asegurar que cualquier byte de 1 o 2 dígitos es válido <strong>0 a 99</strong>, pero de 3 dígitos no es cualquiera válidos ya que los números mayores a 255 no lo son. Luego <strong><code>\d{1,2}</code></strong> sería válida para byte pero nos dejamos fuera del rango de 100 a 255.</li>
<li>Si empieza por 1 el byte, después cualesquier  combinación de 2 dígitos son válidos, esto es: de <strong>100 a 199</strong>. Luego <strong><code>1\d{2}</code></strong> añadiría el rango de 100 a 199 dejando fuera de 200 a 255.</li>
<li>Si empieza por 2 el byte el siguiente dígito va de 0 a 4 el tercer dígito podrá ir de 0 a 9 → <strong><code>\d</code></strong>, ya que si es 5 el tercer dígito solo podrá ir de 0 a 5. Luego <strong><code>2[0-4]\d</code></strong> añadiría el rango de <strong>200 a 249</strong> dejando fuera de 250 a 255.</li>
<li>Ya nos queda añadir el último rango de valores válidos de <strong>250 a 255</strong> a través de la expresión <strong><code>25[0-5]</code></strong><br>
Podemos concluir que la expresión final para un byte válido será <strong><code>(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])</code></strong> con lo cual la expresión final será...<br>
<strong><code>^(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])){3}$</code></strong></li>
</ol>
<p><strong>Nos queda una ER muy larga y ofuscada de leer</strong>, con partes repetidas y donde cometer un error es bastante sencillo. Una posible solución será definir los sub-grupos en variables separadas y así auto-documentar y simplificar quedando la función de arriba así.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronByteIP <span class="token operator">=</span> <span class="token string">@"(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])"</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">"^"</span>
                    <span class="token operator">+</span> patronByteIP <span class="token operator">+</span> <span class="token string">@"(\."</span>
                    <span class="token operator">+</span> patronByteIP <span class="token operator">+</span> <span class="token string">"){3}$"</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Pero... <strong>¿Sería posible obtener los bytes de la IP?</strong><br>
Supongamos que los vamos a devolver en un array de bytes subordinado a si es correcta o no. Por tanto nuestro interfaz quedaría así:<br>
<strong><code>static bool IPCorrecta(string entrada, out byte[]? bytes)</code></strong><br>
y si quisiéramos ver si la IP es correcta sin obtener los bytes, podríamos llamar a la función de siguiente manera:<br>
<strong><code>bool correcta = IPCorrecta(entrada, out _);</code></strong><br>
Fíjate que el caracter <strong><code>_</code></strong> significa descarte como en las expresiones switch.<br>
En este caso sería más simple hacer un Split de la cadena correcta por el caracter de separación de los bytes, que recurrir a definir grupos en la expresión. Una propuesta podría ser el código siguiente...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronByteIP <span class="token operator">=</span> <span class="token string">@"(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])"</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">"^"</span>
                    <span class="token operator">+</span> patronByteIP <span class="token operator">+</span> <span class="token string">@"(\."</span>
                    <span class="token operator">+</span> patronByteIP <span class="token operator">+</span> <span class="token string">"){3}$"</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> ipCorrecta <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ipCorrecta<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-byte">byte</span></span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-foreach">foreach</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> textoByte <span class="token keyword keyword-in">in</span> entrada<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            bytes<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-byte">byte</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>textoByte<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> ipCorrecta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> <span class="token function">LeeIP</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> mensaje<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">;</span>
    <span class="token keyword keyword-bool">bool</span> válida<span class="token punctuation">;</span>
    <span class="token keyword keyword-do">do</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">mensaje</span><span class="token punctuation">}</span></span><span class="token string">: "</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> ip <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string">"0.0.0.0"</span><span class="token punctuation">;</span>
        válida <span class="token operator">=</span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>válida<span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"IP </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">ip</span><span class="token punctuation">}</span></span><span class="token string"> no es válida."</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>válida<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> bytes<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> ip <span class="token operator">=</span> <span class="token function">LeeIP</span><span class="token punctuation">(</span><span class="token string">"Introduce la IP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>ip <span class="token operator">!=</span> <span class="token keyword keyword-null">null</span> 
                      <span class="token punctuation">?</span> <span class="token interpolation-string"><span class="token string">$"La IP introducida es </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp"><span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string">"</span></span> 
                      <span class="token punctuation">:</span> <span class="token string">"IP incorrecta."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div style="page-break-after:always;"></div>
<p>Pero... <strong>¿Sería posible hacerlo definido grupos en la expresión?</strong></p>
<p>Tendríamos que etiquetar cada grupo y con la expresión actual donde agrupamos los 3 últimos grupos no sería posible. Por lo tanto deberíamos desagrupar la ER y el código podría quedar ....</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> grupos <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span><span class="token string">"b1"</span><span class="token punctuation">,</span> <span class="token string">"b2"</span><span class="token punctuation">,</span> <span class="token string">"b3"</span><span class="token punctuation">,</span> <span class="token string">"b4"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronByteIP <span class="token operator">=</span> <span class="token string">@"\d{1,2}|1\d{2}|2[0-4]\d|25[0-5]"</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">"^"</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span> <span class="token operator">+</span> <span class="token string">@"\."</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span> <span class="token operator">+</span> <span class="token string">@"\."</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span> <span class="token operator">+</span> <span class="token string">@"\."</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span> <span class="token operator">+</span> <span class="token string">"$"</span><span class="token punctuation">;</span>
    <span class="token class-name">Match</span> m <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-byte">byte</span></span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grupos<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-byte">byte</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>grupos<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> m<span class="token punctuation">.</span>Success<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div style="page-break-after:always;"></div>
<p>Pero... ya que vamos a sacar grupos, <strong>la comprobación de que el byte esta entre 0 y 255 la podríamos hacer al extraer el byte, y así simplificar bastante la ER haciéndola más legible</strong>.</p>
<p>El código quedaría más legible, pues no tendríamos que pensar tanto la ER. Una posible propuesta podría ser la siguiente:</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> grupos <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span><span class="token string">"b1"</span><span class="token punctuation">,</span> <span class="token string">"b2"</span><span class="token punctuation">,</span> <span class="token string">"b3"</span><span class="token punctuation">,</span> <span class="token string">"b4"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronByteIP <span class="token operator">=</span> <span class="token string">@"\d{1,3}"</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">"^"</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span> <span class="token operator">+</span> <span class="token string">@"\."</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span> <span class="token operator">+</span> <span class="token string">@"\."</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span> <span class="token operator">+</span> <span class="token string">@"\."</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$"(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span> <span class="token operator">+</span> <span class="token string">"$"</span><span class="token punctuation">;</span>
    <span class="token class-name">Match</span> m <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> ipCorrecta <span class="token operator">=</span> m<span class="token punctuation">.</span>Success<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ipCorrecta<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-byte">byte</span></span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grupos<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-byte">byte</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>grupos<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ipCorrecta <span class="token operator">=</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ipCorrecta<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> ipCorrecta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div style="page-break-after:always;"></div>
<p><strong>¿Podríamos llevar este último planteamiento a la expresión anterior con el Split?</strong><br>
Por supuesto y el código también quedaría simple y legible.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp csharp"><code><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">@"^\d{1,3}(\.(\d{1,3})){3}$"</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> ipCorrecta <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ipCorrecta<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> textoBytes <span class="token operator">=</span> entrada<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-byte">byte</span></span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> textoBytes<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-byte">byte</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>textoBytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ipCorrecta <span class="token operator">=</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ipCorrecta<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> ipCorrecta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>A través, de este caso de estudio, hemos visto variar formas de abordar el problema. Siempre tratando de refactorizar y mantera el código lo más legible y simple posible. Con ello ganaremos mantenibilidad y evitaremos errores.<br>
<strong>¿Qué versión crees que es la mejor?</strong></p>
</div>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>