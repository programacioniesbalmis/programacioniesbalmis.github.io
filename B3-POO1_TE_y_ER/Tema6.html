<!DOCTYPE html><html><head>
      <title>Programaci&#xF3;n 1&#xBA; DAM Tema 6</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
      
      
      
      
      
      
      
      
      
      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
.markdown-preview.markdown-preview .slides > section {
  height: 100%;
  font-size: 90%;
  overflow-y: auto !important;
}
.markdown-preview.markdown-preview .slide code {
  color: yellow;
}

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h1 class="mume-header undefined" id="tema-6">Tema 6</h1>

<p>Descargar estos apuntes en <a href="./Tema6.pdf">pdf</a> o <a href="./Tema6.html">html</a></p>
<h2 class="mume-header" id="%C3%ADndice">&#xCD;ndice</h2>

<ol>
<li><a href="#%C3%ADndice">&#xCD;ndice</a></li>
<li><a href="#a-hrefhttpsdocsmicrosoftcomes-esdotnetstandardbase-typesregular-expression-language-quick-referenceredirectedfrommsdn-target_blankexpresiones-regulares-en-ca">Expresiones Regulares en C#</a>
<ol>
<li><a href="#definici%C3%B3n-de-expresi%C3%B3n-regular">Definici&#xF3;n de expresi&#xF3;n regular</a></li>
<li><a href="#caracteres">Caracteres</a></li>
<li><a href="#metacaracteres">Metacaracteres</a>
<ol>
<li><a href="#clases-de-car%C3%A1cter">Clases de car&#xE1;cter</a>
<ol>
<li><a href="#alternancia-de-car%C3%A1cter">Alternancia de car&#xE1;cter</a></li>
</ol>
</li>
<li><a href="#alternancia-de-expresiones">Alternancia de expresiones</a></li>
<li><a href="#aserciones-at%C3%B3micas-de-ancho-cero">Aserciones at&#xF3;micas de ancho cero</a></li>
<li><a href="#construcciones-de-agrupamiento-o-grupos">Construcciones de agrupamiento o grupos</a></li>
<li><a href="#cuantificadores">Cuantificadores</a></li>
<li><a href="#construcciones-de-referencia-inversa">Construcciones de referencia inversa</a></li>
</ol>
</li>
<li><a href="#uso-de-expresiones-regulares-en-el-lenguaje">Uso de expresiones regulares en el lenguaje</a>
<ol>
<li><a href="#m%C3%A9todos-de-utilidad-sobre-cadenas-usando-er">M&#xE9;todos de utilidad sobre cadenas usando ER</a></li>
<li><a href="#gesti%C3%B3n-de-grupos-con-o-sin-etiqueta">Gesti&#xF3;n de grupos con o sin etiqueta</a>
<ol>
<li><a href="#buscar-una-ocurrencia-concreta-con-un-patr%C3%B3n">Buscar una ocurrencia concreta con un patr&#xF3;n</a></li>
<li><a href="#buscar-todas-las-ocurrencias-de-un-patr%C3%B3n">Buscar todas las ocurrencias de un patr&#xF3;n</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<div style="page-break-after:always;"></div>
<h2 class="mume-header" id="a-hrefhttpsdocsmicrosoftcomes-esdotnetstandardbase-typesregular-expression-language-quick-referenceredirectedfrommsdn-target_blankexpresiones-regulares-en-ca"><a href="https://docs.microsoft.com/es-es/dotnet/standard/base-types/regular-expression-language-quick-reference?redirectedfrom=MSDN" target="_blank">Expresiones Regulares en C#</a></h2>

<p>Para probar las expresiones regulares &apos;<em>on-line</em>&apos; podemos usar la siguiente url <a href="https://regexr.com/" target="_blank">regexr.com</a></p>
<h3 class="mume-header" id="definici%C3%B3n-de-expresi%C3%B3n-regular">Definici&#xF3;n de expresi&#xF3;n regular</h3>

<p>Una expresi&#xF3;n regular, a menudo llamada tambi&#xE9;n <strong>patr&#xF3;n</strong>, es una expresi&#xF3;n representada por <strong>caracteres</strong> y <strong>metacaracteres</strong> que describe un <strong>conjunto de cadenas</strong> sin enumerar sus elementos.<br>
A trav&#xE9;s de la expresi&#xF3;n regular es posible interpretar r&#xE1;pidamente vastas cantidades de texto y ejecutar varias operaciones como:</p>
<ul>
<li>Buscar patrones.</li>
<li>Eliminar texto.</li>
<li>Extraer patrones.</li>
</ul>
<h3 class="mume-header" id="caracteres">Caracteres</h3>

<p>Ser&#xE1; todo lo que no sean metacaracteres. Coinciden en la expresi&#xF3;n con ellos mismos.</p>
<h3 class="mume-header" id="metacaracteres">Metacaracteres</h3>

<p>Son caracteres que tienen cierto significado especial &apos;*&apos;, &apos;?&apos;, etc.</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">root<span class="token comment"># ls *.odt</span>
</pre><p>En el enlace del tema podr&#xE1;s ver la especificaci&#xF3;n oficial del la sintaxis soportada por C# para expresiones regulares. Nosotros en este tema hemos hecho un <strong>&apos;<em>resumen</em>&apos;</strong> con las caracter&#xED;sticas m&#xE1;s comunes de las mismas y que podr&#xE1;s encontrar en la mayor&#xED;a de lenguajes.</p>
<div style="page-break-after:always;"></div>
<h4 class="mume-header" id="clases-de-car%C3%A1cter">Clases de car&#xE1;cter</h4>

<p>Son conjuntos de caracteres que encontrar&#xE1;n una correspondencia si uno de los caracteres incluido en el conjunto coincide.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Metacaracter</th>
<th style="text-align:left">Descripci&#xF3;n</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>.</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter menos \n.  Para poner &apos;.&apos;  usaremos \.</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>[aeiou]</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter dentro del grupo</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>[^aeiou]</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter que no pertenezca al grupo</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>[0-9]</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter dentro del rango indicado</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>[0-9A-Z]</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter dentro del rango indicado, con espacio</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\w</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter de palabra <strong><code>[a-zA-Z0-9]</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\W</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter de no-palabra</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\s</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter de espacio</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\S</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter de no-espacio</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\uNNNN</code></strong></td>
<td style="text-align:left">Coincide con cualquier caracter Unicode. Por ejemplo, <strong><code>\u00A9</code></strong> significa &#xA9;</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\d</code></strong></td>
<td style="text-align:left">Coincide con cualquier d&#xED;gito. Otra manera es usar <strong><code>[0-9]</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\D</code></strong></td>
<td style="text-align:left">Coincide con cualquier no-d&#xED;gito. Otra manera es usar <strong><code>[^0-9]</code></strong></td>
</tr>
</tbody>
</table>
<h5 class="mume-header" id="alternancia-de-car%C3%A1cter">Alternancia de car&#xE1;cter</h5>

<p>C# los denomina tambi&#xE9;n <a href="https://docs.microsoft.com/es-es/dotnet/standard/base-types/character-classes-in-regular-expressions#positive-character-group--">&apos;grupo de caracteres positivos&apos;</a>.<br>
La obtendremos con los corchetes <strong><code>[&lt;caracter1&gt;&lt;caracter2&gt;...]</code></strong></p>
<blockquote>
<p><strong>Nota:</strong> Los metacaracteres en el corchete no ser&#xE1; interpretados como tales sino como los caracteres tal cual <strong><code>*, $, +, ?, |</code></strong> &#x2026; salvo el caso de algunas clases de car&#xE1;cter como <strong><code>\d, \D, \w, \W, \s, \S</code></strong> y por tanto la barra de escape <strong><code>\</code></strong> deberemos escaparla si queremos que se interpreta tal cual.</p>
<p>&#x270B; <strong>Importante:</strong> En ocasiones en C# si queremos definir alternancia de caracteres o un grupo de caracteres positivos donde tengamos clases de caracter estas <strong>deber&#xE1;n ir al principio del grupo</strong>. Por ejemplo, <strong><code>@&quot;[\sa-z]&quot;</code></strong> ser&#xED;a alternancia de un caracter de espacio o una letra min&#xFA;scula. Sin embargo, <strong><code>@&quot;[a-z\s]&quot;</code></strong> que funcionar&#xED;a en otros lenguajes podr&#xED;a generarnos errores en ejecuci&#xF3;n &#x1F480;</p>
</blockquote>
<div style="page-break-after:always;"></div>
<h4 class="mume-header" id="alternancia-de-expresiones">Alternancia de expresiones</h4>

<p>Nos sirve para indicar una de varias opciones entre varias expresiones regulares, separadas por el metacaracter barra vertical <strong><code>|</code></strong> (<code>Alt + 124</code> o <code>Alt Gr + 4 y espacio</code>).</p>
<blockquote>
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>este|oeste|norte|sur</code></strong> &#x2192; Permitir&#xE1; encontrar cualquiera de los nombres de los puntos cardinales.</li>
<li><strong><code>\b(mi|[ts]u)\b</code></strong> &#x2192; Permitir&#xE1; encontrar pronombres posesivos.</li>
</ol>
</blockquote>
<h4 class="mume-header" id="aserciones-at%C3%B3micas-de-ancho-cero">Aserciones at&#xF3;micas de ancho cero</h4>

<p>No hacen avanzar el motor a trav&#xE9;s de la cadena de consumo. Simplemente producen coincidencia o error en funci&#xF3;n de la posici&#xF3;n actual en la cadena.</p>
<table>
<thead>
<tr>
<th>Metacaracter</th>
<th>Descripci&#xF3;n</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>^</code></strong></td>
<td>Especifica que la coincidencia debe producirse al principio de la cadena o de la l&#xED;nea.</td>
</tr>
<tr>
<td><strong><code>$</code></strong></td>
<td>Especifica que la coincidencia debe producirse al final de la cadena, antes de <strong><code>\n</code></strong> o al final de la l&#xED;nea.</td>
</tr>
<tr>
<td><strong><code>\A</code></strong></td>
<td>La coincidencia se debe producir al principio de la cadena.</td>
</tr>
<tr>
<td><strong><code>\Z</code></strong></td>
<td>La coincidencia se debe producir al final de la cadena.</td>
</tr>
<tr>
<td><strong><code>\b</code></strong></td>
<td>La coincidencia debe producirse en l&#xED;mites de palabras separadas por caracteres no alfanum&#xE9;rico (letras y n&#xFA;meros).</td>
</tr>
<tr>
<td><strong><code>\B</code></strong></td>
<td>Especifica que la coincidencia <strong>no</strong> se debe producir en un l&#xED;mite <strong><code>\b</code></strong>.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>^\d$</code></strong> &#x2192; Permite asegurar de que la cadena a verificar representa un &#xFA;nico d&#xED;gito, sin nada antes y despu&#xE9;s.</li>
<li><strong><code>^\d\d\/\d\d\/\d\d\d\d$</code></strong> &#x2192; Permite validar un formato de fecha, aunque no permite verificar si es una fecha v&#xE1;lida, ya que 99/99/9999 tambi&#xE9;n ser&#xED;a v&#xE1;lido en este formato.<br>
<strong>Nota:</strong> Aunque C# no lo necesita, es conveniente escapar la barra <strong><code>&quot;/&quot;</code></strong> ya que en otros lenguajes c&#xF3;mo JavaScript es necesario por tanto pondremos <strong><code>@&quot;\/&quot;</code></strong>.</li>
</ol>
</blockquote>
<div style="page-break-after:always;"></div>
<h4 class="mume-header" id="construcciones-de-agrupamiento-o-grupos">Construcciones de agrupamiento o grupos</h4>

<p>Las construcciones de agrupamiento <strong>permiten capturar grupos de sub-expresiones</strong>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Metacaracter</th>
<th style="text-align:left">Descripci&#xF3;n</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>(e)</code></strong></td>
<td style="text-align:left">Captura la subcadena coincidente o grupo sin captura. Las capturas que utilizan <strong><code>()</code></strong> se numeran autom&#xE1;ticamente en funci&#xF3;n del orden del par&#xE9;ntesis de apertura, comenzando por el n&#xFA;mero uno. La primera captura, la captura de elemento n&#xFA;mero cero, es el texto que coincide con el modelo completo de la expresi&#xF3;n regular.</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>(?&lt;nombre&gt;e)</code></strong></td>
<td style="text-align:left">Captura la subcadena coincidente dentro de un nombre de grupo o nombre de n&#xFA;mero. La cadena que se utiliza para nombre no debe contener ning&#xFA;n signo de puntuaci&#xF3;n y no puede comenzar por un n&#xFA;mero.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>al (norte|sur) de</code></strong> &#x2192; Permite crear un grupo sin captura para norte y sur representando las cadenas <em>&#x2026;al <strong>norte</strong> de&#x2026;</em> y <em>&#x2026;al <strong>sur</strong> de&#x2026;</em><br>
<img src="assets\norte_sur.png?0.5325795835369671" alt></li>
<li><strong><code>^(?&lt;dia&gt;\d\d)\/(?&lt;mes&gt;\d\d)\/(?&lt;a&#xF1;o&gt;\d\d\d\d)$</code></strong> &#x2192; Busca la coincidencia exacta con una fecha. Pero <strong>adem&#xE1;s tendremos 3 grupos etiquetados</strong> con las sub-expresiones encontradas en dia, mes y a&#xF1;o.<br>
&#x270B; <strong>Importante:</strong> En C# en el momento que etiquetamos un grupo, <strong>deberemos etiquetar el resto tambi&#xE9;n</strong> o la expresi&#xF3;n no ser&#xE1; v&#xE1;lida.</li>
</ol>
</blockquote>
<div style="page-break-after:always;"></div>
<h4 class="mume-header" id="cuantificadores">Cuantificadores</h4>

<p>Los cuantificadores agregan datos de cantidades opcionales a una expresi&#xF3;n regular. Una expresi&#xF3;n de cuantificador se aplica al car&#xE1;cter, grupo o clase de caracteres que lo precede inmediatamente.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Metacaracter</th>
<th style="text-align:left">Descripci&#xF3;n</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>e*</code></strong></td>
<td style="text-align:left">Especifica 0 o m&#xE1;s coincidencias</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e+</code></strong></td>
<td style="text-align:left">Especifica 1 o m&#xE1;s coincidencias</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e?</code></strong></td>
<td style="text-align:left">Especifica 0 o 1 coincidencias</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e{n}</code></strong></td>
<td style="text-align:left">Especifica exactamente n coincidencias</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e{n,}</code></strong></td>
<td style="text-align:left">Especifica n coincidencias como m&#xED;nimo.</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>e{n,m}</code></strong></td>
<td style="text-align:left">Especifica n coincidencias como m&#xED;nimo y m como m&#xE1;ximo.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>^bo+m{1,4}$</code></strong> &#x2192; Onomatopeya de explosi&#xF3;n.<br>
<img src="assets\boom.png?0.7925969921805678" height="100"></li>
<li><strong><code>^\d{1,2}\/\d{1,2}\/\d{4}$</code></strong> &#x2192; Fecha.<br>
<img src="assets\fecha.png?0.9238630152302139" height="90"></li>
<li><strong><code>\b(?&lt;usuario&gt;[\w._%-]+)@(?&lt;dominio&gt;[\w._]+\.[a-zA-Z]{2,4})\b</code></strong> &#x2192; Correo electr&#xF3;nico (Simplificado).<br>
<img src="assets\correo.png?0.2015776736650461" height="200"></li>
</ol>
</blockquote>
<div style="page-break-after:always;"></div>
<h4 class="mume-header" id="construcciones-de-referencia-inversa">Construcciones de referencia inversa</h4>

<p>Una <a href="https://docs.microsoft.com/es-es/dotnet/standard/base-types/backreference-constructs-in-regular-expressions" target="_blank">construcci&#xF3;n referencia inversa</a> permite identificar una sub-expresi&#xF3;n coincidente previamente m&#xE1;s adelante en la misma expresi&#xF3;n regular.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Metacaracter</th>
<th style="text-align:left">Descripci&#xF3;n</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>\1</code></strong></td>
<td style="text-align:left">Referencia inversa. Coincide con el valor de una sub-expresi&#xF3;n numerada 1&#x2026; n.</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>\k&lt;nombre&gt;</code></strong></td>
<td style="text-align:left">Referencia inversa. Coincide con el valor de una sub-expresi&#xF3;n con nombre.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Ejemplos:</strong></p>
<ol>
<li><strong><code>(\w)\1</code></strong> &#x2192; Devolver&#xE1; &apos;<em>aa</em>&apos; en <em>&apos;<strong>aa</strong>ron&apos;</em></li>
<li><strong><code>(?&lt;letra&gt;\w)\k&lt;letra&gt;</code></strong> &#x2192; Devolver&#xE1; &apos;<em>aa</em>&apos; en <em>&apos;<strong>aa</strong>ron&apos;</em></li>
<li>Su pongamos esta expresi&#xF3;n para detectar fechas:<br>
<strong><code>^\d{1,2}[\s\/-]\d{1,2}[\s\/-]\d{2,4}$</code></strong> Si nos fijamos la separaci&#xF3;n entre los valores de d&#xED;a, mes y a&#xF1;o pueden ser diferentes por lo que podr&#xED;an ser v&#xE1;lidas entradas como: <strong>22/03-2021</strong> y <strong>3-12 2021</strong> pero... <strong>&#xBF;C&#xF3;mo hacernos para asegurarnos que el separador que se ponga entre mes y a&#xF1;o sea el mismo que se consumi&#xF3; entre d&#xED;a y mes?</strong>
<ul>
<li>Lo que quiero ver si se repite o no m&#xE1;s adelante, lo pondr&#xE9; en un grupo.</li>
<li>Her&#xE9; referencia al grupo con los ejemplos que hemos visto m&#xE1;s adelante.<br>
Tendremos pues la espresi&#xF3;n <strong><code>^\d{1,2}([\s\/-])\d{1,2}\1\d{2,4}$</code></strong><br>
<img src="assets\fecha2.png?0.7379966247643082" height="150"></li>
</ul>
</li>
</ol>
</blockquote>
<div style="page-break-after:always;"></div>
<h3 class="mume-header" id="uso-de-expresiones-regulares-en-el-lenguaje">Uso de expresiones regulares en el lenguaje</h3>

<p>Utilizaremos la clase de las BCL <strong><code>Regex</code></strong> definida en el espacio de nombres <strong><code>System.Text.RegularExpressions</code></strong>, que contendr&#xE1; m&#xE9;todos est&#xE1;ticos para usarlas.</p>
<p>A la hora de usar el patr&#xF3;n podemos indicar mediante una serie de flags definidos en el enumerado <a href="https://docs.microsoft.com/es-es/dotnet/api/system.text.regularexpressions.regexoptions?redirectedfrom=MSDN&amp;view=netcore-3.1#campos" target="_blank"><b>RegexOptions</b></a>, c&#xF3;mo se va a comportar el motor de expresiones regulares.</p>
<blockquote>
<p><strong>Ejemplo 1:</strong></p>
<p>Comprobaci&#xF3;n s&#xED;mple de la e.r. para comprobar un e-mail anterior.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;Introduce una e-mail: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> correo <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Las opciones del enumerado para el motor de e.r. ser&#xE1;n un grupo de flags.</span>
    <span class="token class-name">RegexOptions</span> opciones <span class="token operator">=</span> RegexOptions<span class="token punctuation">.</span>Compiled <span class="token operator">|</span> RegexOptions<span class="token punctuation">.</span>IgnoreCase<span class="token punctuation">;</span> 
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patron <span class="token operator">=</span> <span class="token string">@&quot;^[\w.%-]+@[\w.-]+\.[a-zA-Z]{2,4}$&quot;</span><span class="token punctuation">;</span>
    
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> correoValido <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>correo<span class="token punctuation">,</span> patron<span class="token punctuation">,</span> opciones<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;El correo </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">correo</span><span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp"><span class="token punctuation">(</span><span class="token operator">!</span>correoValido <span class="token punctuation">?</span> <span class="token string">&quot;no &quot;</span> <span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string">es v&#xE1;lido.&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></blockquote>
<p>Tambi&#xE9;n tambi&#xE9;n podemos instanciar un objeto de la clase RegEx por si nos interesara aplicar diferentes operaciones sobre el mismo patr&#xF3;n.</p>
<blockquote>
<p><strong>Ejemplo 2:</strong></p>
<p>Igual que el <strong>ejemplo 1</strong> pero rehusando un objeto instanciado de <strong><code>RegEx</code></strong>.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> correoValido<span class="token punctuation">;</span>
    <span class="token class-name">Regex</span> patron <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">Regex</span><span class="token punctuation">(</span><span class="token string">@&quot;^[\w.%-]+@[\w.-]+\.[a-zA-Z]{2,6}$&quot;</span><span class="token punctuation">,</span>
                                RegexOptions<span class="token punctuation">.</span>Compiled <span class="token operator">|</span> RegexOptions<span class="token punctuation">.</span>IgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-do">do</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;Introduce una direcci&#xF3;n de correo: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> correo <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        correoValido <span class="token operator">=</span> patron<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>correo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>correoValido<span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">correo</span><span class="token punctuation">}</span></span><span class="token string"> no es un correo v&#xE1;lido.&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>correoValido<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></blockquote>
<div style="page-break-after:always;"></div>
<h4 class="mume-header" id="m%C3%A9todos-de-utilidad-sobre-cadenas-usando-er">M&#xE9;todos de utilidad sobre cadenas usando ER</h4>

<p>Destacaremos un par de ellos,  tendremos la posibilidad de usarlos tanto sobre un objeto instanciado o como m&#xE9;todos de clase est&#xE1;ticos (nosotros vamos a ver estos &#xFA;ltimos).</p>
<ul>
<li>
<p><strong><code>static string Replace(string cadenaConsumo, string patr&#xF3;n, string reemplazo, RegexOptions opciones)</code></strong><br>
Reemplaza un patr&#xF3;n en la cadena de consumo por una cadena de reemplazo.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token class-name"><span class="token keyword keyword-string">string</span></span> texto1 <span class="token operator">=</span> <span class="token string">&quot;Esta   es una    cadena    con &quot;</span> <span class="token operator">+</span>
                <span class="token string">&quot;un  n&#xFA;mero de     espacios en blanco indeterminado.&quot;</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>texto1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-string">string</span></span> texto2 <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span>texto1<span class="token punctuation">,</span> <span class="token string">@&quot;\s+&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>texto2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><strong><code>static string[] Split(string cadenaConsumo, string patr&#xF3;n, RegexOptions opciones)</code></strong><br>
Trocea una cadena por un patr&#xF3;n.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token class-name"><span class="token keyword keyword-string">string</span></span> texto <span class="token operator">=</span> <span class="token string">&quot;Esta   es una    cadena    con &quot;</span> <span class="token operator">+</span>
               <span class="token string">&quot;un  n&#xFA;mero de     espacios en blanco indeterminado.&quot;</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> palabras <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>texto<span class="token punctuation">,</span> <span class="token string">@&quot;\s+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string">&quot;\n&quot;</span><span class="token punctuation">,</span> palabras<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
</ul>
<h4 class="mume-header" id="gesti%C3%B3n-de-grupos-con-o-sin-etiqueta">Gesti&#xF3;n de grupos con o sin etiqueta</h4>

<p>Utilizaremos la clase <a href="https://docs.microsoft.com/es-es/dotnet/api/system.text.regularexpressions.match?view=netcore-3.1" target="_blank">Match</a> que adem&#xE1;s de contener informaci&#xF3;n de los grupos, me ayudar&#xE1; a gestionar <strong>coincidencias</strong>.</p>
<ul>
<li>
<p>Como ha sucedido hasta ahora, obtendremos un objeto Match a partir de una instancia de objeto <strong><code>RegEx</code></strong> o directamente a trav&#xE9;s de un m&#xE9;todo de clase de RegEx:</p>
<ul>
<li><strong><code>Match objRegex.Match(string cadenaDeEntrada);</code></strong></li>
<li><strong><code>static Match RegEx.Match(string cadenaDeEntrada, string patr&#xF3;n);</code></strong></li>
</ul>
</li>
<li>
<p>Una vez tenemos un objeto <strong><code>Match</code></strong>...</p>
<ul>
<li>Dispondremos de la propiedad <strong><code>bool objMatch.Success</code></strong> que medir&#xE1; si se encontr&#xF3; una coincid&#xE9;ncia o no (del grupo principal).</li>
<li>Dispondremos de la propiedad <strong><code>bool objMatch.Groups</code></strong> que podremos indizar a trav&#xE9;s de un entero o de una cadena con la etiqueta del grupo, y nos devolver&#xE1; el grupo correspondiente.</li>
<li>Dispondremos del m&#xE9;todo de instancia <strong><code>Match objMatch.NextMatch()</code></strong> que continuar&#xE1; buscando coincidencias de la ER que gener&#xF3; el objeto match al que se le aplico.</li>
</ul>
</li>
<li>
<p>Una vez tenemos un objeto <strong><code>Group</code></strong> indizado...</p>
<ul>
<li>Dispondremos de la propiedad <strong><code>string objGroup.Value</code></strong> que me devolver&#xE1; un string con la coincid&#xE9;ncia encontrada.</li>
</ul>
</li>
</ul>
<div style="page-break-after:always;"></div>
<blockquote>
<p><strong>Ejemplo:</strong></p>
<p>Veamos su funcionamiento a trav&#xE9;s de un programa de ejemplo en el que vamos a pedir una fecha con formato <strong><code>dd/mm/aaaa</code></strong> y adem&#xE1;s de ver si es correcta la entrada, vamos a mostrar los valores de d&#xED;a, m&#xE9;s y a&#xF1;o introducidos.</p>
</blockquote>
<pre data-role="codeBlock" data-info="csharp { class=&quot;line-numbers&quot; }" class="language-csharp line-numbers"><span class="token keyword keyword-public">public</span> <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;Introduce una fecha dd/mm/aaaa: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> fecha <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">Regex</span> patronFecha <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name">Regex</span><span class="token punctuation">(</span><span class="token string">@&quot;^(?&lt;Dia&gt;\d{2})\/(?&lt;Mes&gt;\d{2})\/(?&lt;A&#xF1;o&gt;\d{4})$&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Busco la primera y &#xFA;nica coincidencia en la cadena de consumo fecha.</span>
    <span class="token class-name">Match</span> coincidencia <span class="token operator">=</span> patronFecha<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>fecha<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Sabemos con &apos;seguridad&apos; que en los grupos hay valores num&#xE9;ricos</span>
        <span class="token comment">// En este ejemplo como los grupos estaban etiquetados, puedo indexar</span>
        <span class="token comment">// utilizando el nombre de la etiqueta del grupo.</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> dia <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token string">&quot;Dia&quot;</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> mes <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token string">&quot;Mes&quot;</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-ushort">ushort</span> a&#xF1;o <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token string">&quot;A&#xF1;o&quot;</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;Dia = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">dia</span><span class="token punctuation">}</span></span><span class="token string">, Mes = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">mes</span><span class="token punctuation">}</span></span><span class="token string"> y A&#xF1;o = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">a&#xF1;o</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;No ha introducido un formato de fecha v&#xE1;lido.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><div style="page-break-after:always;"></div>
<h5 class="mume-header" id="buscar-una-ocurrencia-concreta-con-un-patr%C3%B3n">Buscar una ocurrencia concreta con un patr&#xF3;n</h5>

<p>Vamos a modificar lig&#xE9;ramente el ejemplo anterior, para que a partir de la cadena <strong>&quot;<em>El 11/9/2001 fueron derribadas las torres gemelas de NY y el 20/7/1969 lleg&#xF3; el hombre a la luna</em>&quot;</strong> me diga si en la misma se encuentra la fecha de la llegada del hombre a la luna con formato <strong><code>dd/mm/aaaa</code></strong> pero esta vez <strong><code>dd</code></strong> y <strong><code>mm</code></strong> pueden estar formados tambi&#xE9;n por una solo d&#xED;gito y <strong>los grupos NO estar&#xE1;n etiquetados</strong>.</p>
<pre data-role="codeBlock" data-info="csharp { class=&quot;line-numbers&quot; }" class="language-csharp line-numbers"><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> texto  <span class="token operator">=</span> <span class="token string">&quot;El 11/9/2001 fueron derribadas las torres gemelas &quot;</span> <span class="token operator">+</span> 
                    <span class="token string">&quot;de NY y el 20/7/1969 lleg&#xF3; el ombre a la luna&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patron <span class="token operator">=</span> <span class="token string">@&quot;(\d{1,2})\/(\d{1,2})\/(\d{4})&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">Match</span> coincidencia    <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>texto<span class="token punctuation">,</span> patron<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span>  fechaEncontrada <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// Mientras no encuentre lo que busco y </span>
    <span class="token comment">// haya coincidencias con el patr&#xF3;n que busco en la cadena.</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fechaEncontrada <span class="token operator">&amp;&amp;</span> coincidencia<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> fecha <span class="token operator">=</span> coincidencia<span class="token punctuation">.</span>Value<span class="token punctuation">;</span> <span class="token comment">// Equivale a coincidencia.Groups[0].Value</span>
        <span class="token comment">// Cada par&#xE9;ntesis en la expresi&#xF3;n para definir un grupo se numerar&#xE1;n </span>
        <span class="token comment">// de izquierda a derecha empezando por 1 ya que el &#xED;ndice 0 es toda la expresi&#xF3;n.</span>
        <span class="token comment">// Puede ser una opci&#xF3;n si tenemos pocos grupos pero no anidados, </span>
        <span class="token comment">// aunque ser&#xE1; menos legible que la anterior.</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> dia <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> mes <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-ushort">ushort</span> a&#xF1;o <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fechaEncontrada <span class="token operator">=</span> dia <span class="token operator">==</span> <span class="token number">20</span> <span class="token operator">&amp;&amp;</span> mes <span class="token operator">==</span> <span class="token number">7</span> <span class="token operator">&amp;&amp;</span> a&#xF1;o <span class="token operator">==</span> <span class="token number">1969</span><span class="token punctuation">;</span>
        <span class="token comment">// NextMatch busca la siguiente coincid&#xE9;ncia si la hay </span>
        <span class="token comment">// a partir de la la &#xFA;ltima que encontr&#xF3;.</span>
        coincidencia <span class="token operator">=</span> coincidencia<span class="token punctuation">.</span><span class="token function">NextMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;La fecha de la llegada a la luna </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp"><span class="token punctuation">(</span>fechaEncontrada<span class="token punctuation">?</span><span class="token string">&quot;no se&quot;</span><span class="token punctuation">:</span><span class="token string">&quot;se&quot;</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string"> &quot;</span></span> <span class="token operator">+</span>
                       <span class="token string">&quot;encuentra en el texto&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><h5 class="mume-header" id="buscar-todas-las-ocurrencias-de-un-patr%C3%B3n">Buscar todas las ocurrencias de un patr&#xF3;n</h5>

<ul>
<li>Usaremos el m&#xE9;todo <strong><code>Regex.Matches(cadena, patr&#xF3;n, ...)</code></strong> que me devolver&#xE1; una colecci&#xF3;n indexable y recorrible con <strong><code>foreach</code></strong> con todas las coincidencias.</li>
<li>Este caso ser&#xE1; &#xFA;til, si queremos obtener <strong>todas</strong> las coincidencias, y no una en concreto que puede que la encontremos justo al principio, con lo cual esta opci&#xF3;n ser&#xED;a m&#xE1;s costosa.</li>
</ul>
<pre data-role="codeBlock" data-info="csharp {highlight=1}" class="language-csharp" data-line="1">    <span class="token keyword keyword-foreach">foreach</span><span class="token punctuation">(</span><span class="token class-name">Match</span> coincidencia <span class="token keyword keyword-in">in</span> Regex<span class="token punctuation">.</span><span class="token function">Matches</span><span class="token punctuation">(</span>texto<span class="token punctuation">,</span> patron<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> fecha <span class="token operator">=</span> coincidencia<span class="token punctuation">.</span>Value<span class="token punctuation">;</span> <span class="token comment">// Equivale a coincidencia.Groups[0].Value</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> dia <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-ushort">ushort</span></span> mes <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-ushort">ushort</span> a&#xF1;o <span class="token operator">=</span> <span class="token keyword keyword-ushort">ushort</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>coincidencia<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;Fecha encontrada </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">fecha</span><span class="token punctuation">}</span></span><span class="token string"> Dia = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">dia</span><span class="token punctuation">}</span></span><span class="token string">, Mes = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">mes</span><span class="token punctuation">}</span></span><span class="token string"> y A&#xF1;o = </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">a&#xF1;o</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<div class="line-highlight-wrapper"><div aria-hidden="true" class="line-highlight" data-range="1" data-start="1">
</div></div></pre><div style="page-break-after:always;"></div>
<blockquote>
<p><strong>&#x1F393; Caso de estudio</strong></p>
<p>Supongamos que queremos hacer un m&#xE9;todo de utilidad que nos diga si una <strong>IP</strong> de entrada es correcta.<br>
Adem&#xE1;s, usaremos ese m&#xE9;todo como apoyo a otro que lea una IP desde teclado y filtre solo valores v&#xE1;lidos.</p>
<p><strong>Nota:</strong> Una <strong>IP</strong> esta formada por <strong>cuatro bytes</strong> separados por punto de <strong><code>0</code></strong> a <strong><code>255</code></strong> por ejemplo <strong><code>10.0.2.254</code></strong></p>
<p>Una primera aproximaci&#xF3;n, podr&#xED;a ser dar como v&#xE1;lidas tres secuencias de <strong>1 a 3 d&#xED;gitos</strong> separadas por un <strong><code>.</code></strong> con nada antes <strong><code>^</code></strong> y despu&#xE9;s <strong><code>$</code></strong>. Por tanto el patr&#xF3;n podr&#xED;a quedar algo as&#xED;:<br>
<strong><code>^\d{1,3}\.\d{1,3}\.\d{1,3}.\d{1,3}$</code></strong>.<br>
F&#xED;jate, que hemos escapado el caracter <strong><code>&apos;.&apos;</code></strong> por ser un metacaracter de las clase de caracter y queremos se interprete de forma literal.<br>
A primera vista, se repiten tres partes en la expresi&#xF3;n compuestas por el caracter <strong><code>&apos;.&apos;</code></strong> seguido de 3 d&#xED;gitos, por lo que podr&#xED;amos simplificar la expresi&#xF3;n as&#xED;:<br>
<strong><code>^\d{1,3}(\.\d{1,3}){3}$</code></strong><br>
F&#xED;jate, para indicar que lo que se repite 3 veces es eso hemos tenido que agruparlo en una sub-expresi&#xF3;n.<br>
Una vez hemos decidido la expresi&#xF3;n regular nuestro c&#xF3;digo podr&#xED;a quedar as&#xED;.</p>
<pre data-role="codeBlock" data-info="csharp { class=&quot;line-numbers&quot; }" class="language-csharp line-numbers"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">Programa</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">@&quot;^\d{1,3}(\.\d{1,3}){3}$&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-string">string</span></span> <span class="token function">LeeIP</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> mensaje<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-bool">bool</span> v&#xE1;lida<span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> ip<span class="token punctuation">;</span>
        <span class="token keyword keyword-do">do</span>
        <span class="token punctuation">{</span>
            Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">mensaje</span><span class="token punctuation">}</span></span><span class="token string">: &quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ip <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            v&#xE1;lida <span class="token operator">=</span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v&#xE1;lida<span class="token punctuation">)</span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;IP </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">ip</span><span class="token punctuation">}</span></span><span class="token string"> no es v&#xE1;lida.&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>v&#xE1;lida<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword keyword-return">return</span> ip<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> ip <span class="token operator">=</span> <span class="token function">LeeIP</span><span class="token punctuation">(</span><span class="token string">&quot;Introduce la IP&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;La IP introducida es </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">ip</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre><p>Pero... <strong>&#xBF;Es posible controlar que los bytes est&#xE9;n entre 0 y 255 en la propia expresi&#xF3;n?</strong></p>
<p>En este caso tendremos que indicar alg&#xFA;n tipo de alternancia de posibilidades para incluir r&#xE1;ngos excluyentes en la expresi&#xF3;n...</p>
<ol>
<li>Podemos asegurar que cualquier byte de 1 o 2 d&#xED;gitos es v&#xE1;lido <strong>0 a 99</strong>, pero de 3 d&#xED;gitos no es cualquiera v&#xE1;lidos ya que los n&#xFA;meros mayores a 255 no lo son. Luego <strong><code>\d{1,2}</code></strong> ser&#xED;a v&#xE1;lida para byte pero nos dejamos fuera del rango de 100 a 255.</li>
<li>Si empieza por 1 el byte, despu&#xE9;s cualesquier  combinaci&#xF3;n de 2 d&#xED;gitos son v&#xE1;lidos, esto es: de <strong>100 a 199</strong>. Luego <strong><code>1\d{2}</code></strong> a&#xF1;adir&#xED;a el rango de 100 a 199 dejando fuera de 200 a 255.</li>
<li>Si empieza por 2 el byte el siguiente d&#xED;gito va de 0 a 4 el tercer d&#xED;gito podr&#xE1; ir de 0 a 9 &#x2192; <strong><code>\d</code></strong>, ya que si es 5 el tercer d&#xED;gito solo podr&#xE1; ir de 0 a 5. Luego <strong><code>2[0-4]\d</code></strong> a&#xF1;adir&#xED;a el rango de <strong>200 a 249</strong> dejando fuera de 250 a 255.</li>
<li>Ya nos queda a&#xF1;adir el &#xFA;ltimo rango de valores v&#xE1;lidos de <strong>250 a 255</strong> a trav&#xE9;s de la expresi&#xF3;n <strong><code>25[0-5]</code></strong></li>
</ol>
<p>Podemos concluir que la expresi&#xF3;n final para un byte v&#xE1;lido ser&#xE1; <strong><code>(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])</code></strong> con lo cual la expresi&#xF3;n final ser&#xE1;...<br>
<strong><code>^(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])(\.(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])){3}$</code></strong><br>
<strong>Nos queda una ER muy larga y ofuscada de leer</strong>, con partes repetidas y donde cometer un error es bastante sencillo. Una posible soluci&#xF3;n ser&#xE1; definir los sub-grupos en variables separadas y as&#xED; auto-documentar y simplificar quedando la funci&#xF3;n de arriba as&#xED;.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronByteIP <span class="token operator">=</span> <span class="token string">@&quot;(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">&quot;^&quot;</span>
                    <span class="token operator">+</span> patronByteIP <span class="token operator">+</span> <span class="token string">@&quot;(\.&quot;</span>
                    <span class="token operator">+</span> patronByteIP <span class="token operator">+</span> <span class="token string">&quot;){3}$&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></blockquote>
<div style="page-break-after:always;"></div>
<blockquote>
<p>Pero... <strong>&#xBF;Ser&#xED;a posible obtener los bytes de la IP?</strong></p>
<p>Supongamos que los vamos a devolver en un array de bytes subordinado a si es correcta o no. Por tanto nuestro interfaz quedar&#xED;a as&#xED;:<br>
<strong><code>static bool IPCorrecta(string entrada, out byte[]? bytes)</code></strong><br>
y si quisi&#xE9;ramos ver si la IP es correcta sin obtener los bytes, podr&#xED;amos llamar a la funci&#xF3;n de siguiente manera:<br>
<strong><code>bool correcta = IPCorrecta(entrada, out _);</code></strong><br>
F&#xED;jate que el caracter <strong><code>_</code></strong> significa descarte como en las expresiones switch.<br>
En este caso ser&#xED;a m&#xE1;s simple hacer un Split de la cadena correcta por el caracter de separaci&#xF3;n de los bytes, que recurrir a definir grupos en la expresi&#xF3;n. Una propuesta podr&#xED;a ser el c&#xF3;digo siguiente...</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronByteIP <span class="token operator">=</span> <span class="token string">@&quot;(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">&quot;^&quot;</span>
                    <span class="token operator">+</span> patronByteIP <span class="token operator">+</span> <span class="token string">@&quot;(\.&quot;</span>
                    <span class="token operator">+</span> patronByteIP <span class="token operator">+</span> <span class="token string">&quot;){3}$&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> ipCorrecta <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ipCorrecta<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-byte">byte</span></span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-foreach">foreach</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> textoByte <span class="token keyword keyword-in">in</span> entrada<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string character">&apos;.&apos;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            bytes<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-byte">byte</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>textoByte<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> ipCorrecta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> <span class="token function">LeeIP</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> mensaje<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">;</span>
    <span class="token keyword keyword-bool">bool</span> v&#xE1;lida<span class="token punctuation">;</span>
    <span class="token keyword keyword-do">do</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">mensaje</span><span class="token punctuation">}</span></span><span class="token string">: &quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span></span> ip <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string">&quot;0.0.0.0&quot;</span><span class="token punctuation">;</span>
        v&#xE1;lida <span class="token operator">=</span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v&#xE1;lida<span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;IP </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">ip</span><span class="token punctuation">}</span></span><span class="token string"> no es v&#xE1;lida.&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>v&#xE1;lida<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> bytes<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-void">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> ip <span class="token operator">=</span> <span class="token function">LeeIP</span><span class="token punctuation">(</span><span class="token string">&quot;Introduce la IP&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>ip <span class="token operator">!=</span> <span class="token keyword keyword-null">null</span> 
                      <span class="token punctuation">?</span> <span class="token interpolation-string"><span class="token string">$&quot;La IP introducida es </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp"><span class="token keyword keyword-string">string</span><span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token string character">&apos;.&apos;</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span> 
                      <span class="token punctuation">:</span> <span class="token string">&quot;IP incorrecta.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></blockquote>
<div style="page-break-after:always;"></div>
<blockquote>
<p>Pero... <strong>&#xBF;Ser&#xED;a posible hacerlo definido grupos en la expresi&#xF3;n?</strong></p>
<p>Tendr&#xED;amos que etiquetar cada grupo y con la expresi&#xF3;n actual donde agrupamos los 3 &#xFA;ltimos grupos no ser&#xED;a posible. Por lo tanto deber&#xED;amos desagrupar la ER y el c&#xF3;digo podr&#xED;a quedar ....</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> grupos <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span><span class="token string">&quot;b1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b3&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b4&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronByteIP <span class="token operator">=</span> <span class="token string">@&quot;\d{1,2}|1\d{2}|2[0-4]\d|25[0-5]&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">&quot;^&quot;</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$&quot;(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)&quot;</span></span> <span class="token operator">+</span> <span class="token string">@&quot;\.&quot;</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$&quot;(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)&quot;</span></span> <span class="token operator">+</span> <span class="token string">@&quot;\.&quot;</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$&quot;(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)&quot;</span></span> <span class="token operator">+</span> <span class="token string">@&quot;\.&quot;</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$&quot;(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)&quot;</span></span> <span class="token operator">+</span> <span class="token string">&quot;$&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">Match</span> m <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-byte">byte</span></span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grupos<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-byte">byte</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>grupos<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> m<span class="token punctuation">.</span>Success<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></blockquote>
<div style="page-break-after:always;"></div>
<blockquote>
<p>Pero... ya que vamos a sacar grupos, <strong>la comprobaci&#xF3;n de que el byte esta entre 0 y 255 la podr&#xED;amos hacer al extraer el byte, y as&#xED; simplificar bastante la ER haci&#xE9;ndola m&#xE1;s legible</strong>.</p>
<p>El c&#xF3;digo quedar&#xED;a m&#xE1;s legible, pues no tendr&#xED;amos que pensar tanto la ER. Una posible propuesta podr&#xED;a ser la siguiente:</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> grupos <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">{</span><span class="token string">&quot;b1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b3&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b4&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronByteIP <span class="token operator">=</span> <span class="token string">@&quot;\d{1,3}&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">&quot;^&quot;</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$&quot;(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)&quot;</span></span> <span class="token operator">+</span> <span class="token string">@&quot;\.&quot;</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$&quot;(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)&quot;</span></span> <span class="token operator">+</span> <span class="token string">@&quot;\.&quot;</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$&quot;(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)&quot;</span></span> <span class="token operator">+</span> <span class="token string">@&quot;\.&quot;</span>
                    <span class="token operator">+</span> <span class="token interpolation-string"><span class="token string">$&quot;(?&lt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">grupos<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span></span><span class="token punctuation">}</span></span><span class="token string">&gt;</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">patronByteIP</span><span class="token punctuation">}</span></span><span class="token string">)&quot;</span></span> <span class="token operator">+</span> <span class="token string">&quot;$&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">Match</span> m <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> ipCorrecta <span class="token operator">=</span> m<span class="token punctuation">.</span>Success<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ipCorrecta<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-byte">byte</span></span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grupos<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-byte">byte</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>grupos<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ipCorrecta <span class="token operator">=</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ipCorrecta<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> ipCorrecta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></blockquote>
<div style="page-break-after:always;"></div>
<blockquote>
<p><strong>&#xBF;Podr&#xED;amos llevar este &#xFA;ltimo planteamiento a la expresi&#xF3;n anterior con el Split?</strong></p>
<p>Por supuesto y el c&#xF3;digo tambi&#xE9;n quedar&#xED;a simple y legible.</p>
<pre data-role="codeBlock" data-info="csharp" class="language-csharp"><span class="token keyword keyword-static">static</span> <span class="token return-type class-name"><span class="token keyword keyword-bool">bool</span></span> <span class="token function">IPCorrecta</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-string">string</span></span> entrada<span class="token punctuation">,</span> <span class="token keyword keyword-out">out</span> <span class="token class-name"><span class="token keyword keyword-byte">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">?</span></span> bytes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword keyword-string">string</span></span> patronIP <span class="token operator">=</span> <span class="token string">@&quot;^\d{1,3}(\.(\d{1,3})){3}$&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword keyword-bool">bool</span></span> ipCorrecta <span class="token operator">=</span> Regex<span class="token punctuation">.</span><span class="token function">IsMatch</span><span class="token punctuation">(</span>entrada<span class="token punctuation">,</span> patronIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ipCorrecta<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword keyword-string">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> textoBytes <span class="token operator">=</span> entrada<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string character">&apos;.&apos;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token constructor-invocation class-name"><span class="token keyword keyword-byte">byte</span></span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword keyword-int">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> textoBytes<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword keyword-byte">byte</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>textoBytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ipCorrecta <span class="token operator">=</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ipCorrecta<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
        bytes <span class="token operator">=</span> <span class="token keyword keyword-null">null</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> ipCorrecta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>A trav&#xE9;s, de este caso de estudio, hemos visto variar formas de abordar el problema. Siempre tratando de refactorizar y mantera el c&#xF3;digo lo m&#xE1;s legible y simple posible. Con ello ganaremos mantenibilidad y evitaremos errores.<br>
<strong>&#xBF;Qu&#xE9; versi&#xF3;n crees que es la mejor?</strong></p>
</blockquote>

      </div>
      
      
    
    
    
    
    
    
    
    
  
    </body></html>